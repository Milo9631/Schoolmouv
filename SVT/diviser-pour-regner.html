<html>
<head>
<meta charset="utf-8">
<title>Diviser pour régner : cours de Terminale - Numérique et science</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Diviser pour régner : cours de Terminale - Numérique et science">
<meta name="description" content="SchoolMouv ® te propose ce cours sur Diviser pour régner (Terminale - Numérique et sciences informatiques) pour TOUT comprendre avec ✔️ vidéo ✔️ fiche de révision ✔️ exercices…">
<link rel="canonical" href="https://www.schoolmouv.fr/cours/diviser-pour-regner/fiche-de-cours">
<link rel="icon" href="/content/favicon.ico">
<script id="json-ld" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://www.schoolmouv.fr","name":"Accueil"}},{"@type":"ListItem","position":2,"item":{"@id":"https://www.schoolmouv.fr/terminale","name":"Tle"}},{"@type":"ListItem","position":3,"item":{"@id":"https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques","name":"Numérique et sciences informatiques"}},{"@type":"ListItem","position":4,"item":{"@id":"https://www.schoolmouv.fr/cours/diviser-pour-regner/fiche-de-cours","name":"Cours : Diviser pour régner"}}]}</script><meta name="next-head-count" content="8">
<meta name="next-font-preconnect">
<link rel="preload" href="/content/_next/static/css/c08fcb46814d24f9.css" as="style">
<link rel="stylesheet" href="/content/_next/static/css/c08fcb46814d24f9.css" data-n-g="">
<link rel="preload" href="/content/_next/static/css/08a7cf401873c9c5.css" as="style">
<link rel="stylesheet" href="/content/_next/static/css/08a7cf401873c9c5.css" data-n-p="">
<noscript data-n-css=""></noscript>
<script defer nomodule="" src="/content/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/content/_next/static/chunks/webpack-76dd136e829fd452.js" defer></script><script src="/content/_next/static/chunks/framework-4556c45dd113b893.js" defer></script><script src="/content/_next/static/chunks/main-51dcb152610665c9.js" defer></script><script src="/content/_next/static/chunks/pages/_app-335f32e3eeadaa95.js" defer></script><script src="/content/_next/static/chunks/175675d1-35a00f33118876fa.js" defer></script><script src="/content/_next/static/chunks/583-0b1ac7b20f64a25b.js" defer></script><script src="/content/_next/static/chunks/931-d71cc6dae2d04401.js" defer></script><script src="/content/_next/static/chunks/pages/cours/%5BsheetSlug%5D/%5BresourceType%5D-5a97fb82aa7779c0.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_buildManifest.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_ssgManifest.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_middlewareManifest.js" defer></script>
</head>
<body>
<div id="__next">
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-55RGLG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<div class="main-layout_main-layout__5glmx">
<main id="top"><div class="main-layout-content_main-layout-content__tzGx6">
<div><div class="sheet-template_sheet-sidebar__poLNy sidebar-module_sidebar__ruXSQ"></div></div>
<div>
<div class="main-layout-content_main-layout-content__breadcrumb__gn0rg breadcrumb-module_breadcrumb__r-ILp">
<a style="height:14px" href="https://www.schoolmouv.fr"></a><img height="8" width="11" src="https://images.schoolmouv.fr/assets/icons/arrow.svg" alt="arrow"><a href="https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques" class=" link-module_xxx__aw2PQ link-module_xxx--large__UT8xp link-module_xxx--default__2faDQ link-module_xxx--global__pTt-C"> <!-- -->Numérique et sciences informatiques</a><h1>Cours : Diviser pour régner</h1>
</div>
<div class="sheet-template_sheet__nXEoV">
<div><div class="luna-title_luna-title__kZRX8"><p>Diviser pour régner</p></div></div>
<div class="sheet-template_sheet__info-banner--container__ni_Oi"></div>
<div><div class="react-luna-container luna-content_luna-content__GPj_Y">
<div class="introduction" markdown="1">
<p>Introduction :</p>
<p>La méthode « diviser pour régner » est une approche de résolution de problèmes qui consiste à décomposer un problème complexe en sous-problèmes plus faciles à traiter afin de résoudre le problème initial.</p>
<p>Nous allons dans un premier temps définir et caractériser la méthode « diviser pour régner ». Nous étudierons ensuite son application avec deux algorithmes mettant en œuvre ce paradigme : la recherche dichotomique et le tri-fusion.</p>
</div>
<h2 range="1" markdown="1"><div markdown="1"><p>Principes généraux</p></div></h2>
<h3 range="a." markdown="1"><div markdown="1"><p>Origine et applications</p></div></h3>
<ul>

<li>La <b>méthode du tri-fusion</b>, appliquant le principe « diviser pour régner », a été inventée en 1945 par le mathématicien et informaticien américano-hongrois John von Neumann.</li>

<li>La <b>méthode algorithmique</b> « diviser pour régner » a été formalisée en 1946 pour la recherche dichotomique par le physicien américain John William Mauchly.</li>
</ul>
<p>Mais les principes algorithmiques de type « diviser pour régner » sont eux-mêmes beaucoup plus anciens. Plusieurs siècles avant notre ère, les Babyloniens avaient conceptualisé cette méthode pour faciliter la recherche parmi un ensemble de dates ordonnées chronologiquement.<br>
L’algorithme d’Euclide constitue un autre exemple d’approche « diviser pour régner ».</p>
<div class="blocks definition" markdown="1">
<div class="blocks-icon">
<img src="/content/images/definition.svg" alt="bannière definition">
<p>Définition</p>
</div>
<div class="blocks-text" markdown="1">
<p><b>Méthode « diviser pour régner » :</b></p>
<p>Le paradigme de programmation « diviser pour régner » consiste à décomposer un problème général en petits sous-problèmes plus simples à résoudre, permettant par recomposition d’aboutir à la résolution du problème général.</p>
</div>
</div>
<p>Cette méthode est appelée ainsi en référence à sa désignation anglaise : <em>divide and conquer</em>.</p>
<h3 range="b." markdown="1"><div markdown="1"><p>Principales caractéristiques</p></div></h3>
<p>Le paradigme de programmation « diviser pour régner » nécessite que le problème à résoudre soit décomposable en sous-problèmes, cette décomposition pouvant être récursive. Il s’agit d’une approche de haut en bas, également appelée <b>approche descendante</b>.</p>
<div class="blocks attention" markdown="1">
<div class="blocks-icon">
<img src="/content/images/attention.svg" alt="bannière attention">
<p>Attention</p>
</div>
<div class="blocks-text" markdown="1">
<p>La décomposition du problème en sous-problèmes est également pratiquée dans le cadre du paradigme de programmation dynamique qui fait l’objet d’un cours distinct.<br>
La principale différence entre les deux approches réside dans l’indépendance ou non des sous-problèmes :</p>
<ul>

<li class="liste2">
<div class="list_text">dans le paradigme « diviser pour régner » les problèmes sont différents les uns des autres, ils ne se répètent pas ;</div>
</li>

<li class="liste2">
<div class="list_text">dans le paradigme de programmation dynamique, les sous-problèmes ne sont pas tous, ils se chevauchent.</div>
</li>
</ul>
</div>
</div>
<p>L’approche « diviser pour régner » comporte trois étapes : <b>diviser</b>, <b>régner</b> et <b>combiner</b>. Seules les deux premières étapes sont explicitées dans la dénomination du paradigme « diviser pour régner », mais une étape de combinaison des solutions aux sous-problèmes est nécessaire pour aboutir à la résolution du problème général.<br>
Étudions plus précisément chacune de ces trois étapes.</p>
<h3 range="c." markdown="1"><div markdown="1"><p>Étapes</p></div></h3>
<div class="blocks a_retenir" markdown="1">
<div class="blocks-icon">
<img src="/content/images/a-retenir.svg" alt="bannière à retenir">
<p>À retenir</p>
</div>
<div class="blocks-text" markdown="1">
<p>L’ordre des étapes est le suivant :</p>
<ul>

<li class="bullet_list">
<div style="" range="1"></div>
<div class="list_text">diviser</div>
</li>

<li class="bullet_list">
<div style="" range="2"></div>
<div class="list_text">régner</div>
</li>

<li class="bullet_list">
<div style="" range="3"></div>
<div class="list_text">combiner</div>
</li>
</ul>
</div>
</div>
<p>Le schéma de principe ci-après permet de visualiser l’articulation des étapes successives.</p>
<div class="image_container" style="width:85%;" markdown="1"><div class="image_zoom" markdown="1"><p><img src="https://images-schoolmouv-cours.s3.eu-west-1.amazonaws.com/t-fnx-nsi-c18-img01.png" alt="Étapes du paradigme de programmation diviser pour régner"> 
<span>Étapes du paradigme de programmation « diviser pour régner »
 </span></p></div></div>
<ul>

<li class="bullet_list">
<div style="" range="1"></div>
<div class="list_text">L’étape « diviser » (<em>divide</em> en anglais) consiste à décomposer le problème principal en sous-problèmes.</div>
</li>

<li class="bullet_list">
<div style="" range="2"></div>
<div class="list_text">L’étape « régner » (ou « conquérir » pour <em>conquer</em> en anglais) consiste à résoudre individuellement chacun des sous-problèmes.</div>
</li>

<li class="bullet_list">
<div style="" range="3"></div>
<div class="list_text">L’étape « combiner » (ou « recombiner ») consiste à fusionner l'ensemble des résultats obtenus pour chacun des sous-problèmes afin d’obtenir en résultat final la solution du problème général initialement posé.</div>
</li>
</ul>
<p>Ces sous-problèmes peuvent eux-mêmes être décomposés en sous-problèmes selon une logique récursive. En cas de divisions multiples, il y aura, après les résolutions des sous-problèmes individuels, autant d’étapes de recombinaison qu’il y a eu d’étapes de division.</p>
<p>Le schéma ci-après illustre le processus avec plusieurs niveaux de divisions et de recombinaisons.</p>
<div class="image_container" style="width:100%;" markdown="1"><div class="image_zoom" markdown="1"><p><img src="https://images-schoolmouv-cours.s3.eu-west-1.amazonaws.com/t-fnx-nsi-c18-img02.png" alt="paradigme de programmation diviser pour régner"> 
<span>Paradigme de programmation « diviser pour régner » avec plusieurs niveaux de division et de combinaison
 </span></p></div></div>
<ul>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">Le schéma montre que chaque problème ou sous-problème est décomposé en deux sous-problèmes. Cette division par deux est la plus fréquente, mais la méthode pourrait s’appliquer avec une décomposition en un nombre plus important de sous-problèmes d’un même niveau.</div>
</li>
</ul>
<div class="blocks a_retenir" markdown="1">
<div class="blocks-icon">
<img src="/content/images/a-retenir.svg" alt="bannière à retenir">
<p>À retenir</p>
</div>
<div class="blocks-text" markdown="1"><p>Lors de la décomposition de problèmes en sous-problèmes, on fait en sorte que les sous-problèmes soient, dans la mesure du possible, de tailles comparables. </p></div>
</div>
<p>L’<b>implémentation récursive</b> est généralement privilégiée dans ce contexte, mais il est également possible de réaliser des <b>implémentations itératives</b> de la méthode « diviser pour régner ».</p>
<p>Maintenant que nous avons défini les principales caractéristiques de cette méthode algorithmique, nous allons en étudier deux applications, d’abord la <b>recherche dichotomique</b>, puis le <b>tri-fusion</b>.</p>
<h2 range="2" markdown="1"><div markdown="1"><p>Recherche dichotomique</p></div></h2>
<h3 range="a." markdown="1"><div markdown="1"><p>Principes généraux</p></div></h3>
<div class="blocks definition" markdown="1">
<div class="blocks-icon">
<img src="/content/images/definition.svg" alt="bannière definition">
<p>Définition</p>
</div>
<div class="blocks-text" markdown="1">
<p><b>Recherche dichotomique :</b></p>
<p>La recherche dichotomique consiste à vérifier si un élément est présent dans un ensemble ordonné. Cette recherche par dichotomie est parfois appelée « fouille dichotomique » ou encore « recherche binaire ». </p>
</div>
</div>
<p>On utilise couramment cette méthode, sans nécessairement en connaître le nom : chaque fois que l’on cherche un mot dans un dictionnaire par exemple, ou lorsqu’on nous propose de deviner un nombre.</p>
<div class="blocks exemple" markdown="1">
<div class="blocks-icon">
<img src="/content/images/exemple.svg" alt="bannière exemple">
<p>Exemple</p>
</div>
<div class="blocks-text" markdown="1"><p>Si on nous demande de deviner un nombre entre $1$ et $100$, on va commencer par proposer $50$. Si c’est moins, on sait que le nombre est à chercher entre $1$ et $49$ et on proposera $25$. Si c’est plus de $25$, on proposera $37$, là encore pour être à peu près à la moitié de l’intervalle entre $26$ et $49$. Et ainsi de suite jusqu’à trouver le nombre mystère.</p></div>
</div>
<p>Ainsi, on tend vers l’élément <b>médian</b> de l’ensemble considéré. Si ce n’est pas l’élément recherché, on poursuit la recherche dans la première ou dans la seconde partie de l’ensemble, en fonction du résultat de la comparaison entre l’élément recherché et l’élément médian auquel on l’a comparé :</p>
<ul>

<li class="liste2">
<div class="list_text">si l’élément médian est supérieur à l’élément recherché, l’élément recherché est nécessairement dans la première partie de l’ensemble ;</div>
</li>

<li class="liste2">
<div class="list_text">si l’élément médian est inférieur à l’élément recherché, l’élément recherché est nécessairement dans la seconde partie de l’ensemble.</div>
</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">On applique cette même logique à chaque sous-partie jusqu’à trouver l’élément recherché, s’il est présent.</div>
</li>
</ul>
<p>Cette méthode très simple est aussi très efficace. On élimine en effet chaque fois la moitié de l’ensemble des possibles. La réduction est donc très rapide, même pour de grands ensembles. La complexité de l’algorithme de recherche dichotomique est $O(log(n))$.</p>
<div class="blocks attention" markdown="1">
<div class="blocks-icon">
<img src="/content/images/attention.svg" alt="bannière attention">
<p>Attention</p>
</div>
<div class="blocks-text" markdown="1"><p>La méthode de recherche dichotomique s’effectue nécessairement sur un ensemble de données préalablement <b>triées</b>, conventionnellement par ordre croissant. La méthode s’appuie en effet sur l’ordre de classement des éléments pour pouvoir en éliminer la moitié à chaque étape.</p></div>
</div>
<p>Nous allons réaliser une implémentation de recherche dichotomique pour indiquer si un nombre est, ou non, présent dans une liste triée de nombres entiers.<br>
Il convient ici de préciser que la recherche dichotomique est généralement rattachée au paradigme « diviser pour régner », mais avec la particularité de ne pas résoudre tous les sous-problèmes, puisque la moitié du problème est éliminée à chaque étape, ainsi que nous allons l’illustrer en décomposant ces étapes avec un exemple.</p>
<h3 range="b." markdown="1"><div markdown="1"><p>Décomposition des étapes</p></div></h3>
<p>Nous disposons d’une séquence de nombre entiers triés par ordre croissant : $3$, $6$, $7$, $9$, $15$, $17$, $23$, $36$, $42$. Nous souhaitons vérifier si le nombre $9$ est présent dans cette liste en utilisant la recherche dichotomique.</p>
<div class="image_container" style="width:100%;" markdown="1"><div class="image_zoom" markdown="1"><p><img src="https://images-schoolmouv-cours.s3.eu-west-1.amazonaws.com/t-fnx-nsi-c18-img03.png" alt="recherche dichotomique"> 
<span>Étapes successives de traitement sur la séquence de nombres
 </span></p></div></div>
<p>À chaque étape du processus nous déterminons le milieu de la liste, qui est comparé au nombre recherché pour éliminer la demi-liste qui ne peut pas le contenir. On continue jusqu’à le trouver, s’il est présent, ou à constater son absence.</p>
<p>Dans notre illustration, le nombre $9$ est présent. Il devient l’élément milieu lors de l’étape où la liste est réduite à un seul élément. Si nous avions recherché le nombre $8$, nous aurions constaté à ce stade son absence.</p>
<p>Nous avons présenté les étapes aboutissant aux deux cas de base possibles :</p>
<ul>

<li class="liste2">
<div class="list_text">la présence du nombre recherché ;</div>
</li>

<li class="liste2">
<div class="list_text">l’absence du nombre recherché.</div>
</li>
</ul>
<p>Constater l’absence du nombre recherché nécessite d’aller jusqu’au bout des divisions possibles de la liste de départ. En revanche la découverte du nombre recherché peut s’avérer beaucoup plus rapide :</p>
<ul>

<li class="liste2">
<div class="list_text">il suffit d’une seule division pour ensuite découvrir le nombre $6$ figurant au milieu de la demi-liste conservée ;</div>
</li>

<li class="liste2">
<div class="list_text">aucune division n’est nécessaire pour découvrir le nombre $15$ puisqu’il est situé au milieu de la liste de départ.</div>
</li>
</ul>
<h3 range="c." markdown="1"><div markdown="1"><p>Implémentation</p></div></h3>
<p>L’implémentation récursive est une transposition assez littérale des étapes que nous venons d’illustrer.<br>
Les deux cas de base possibles sont :</p>
<ul>

<li class="liste2">
<div class="list_text">la découverte du nombre cherché, qui peut survenir à tout moment ;</div>
</li>

<li class="liste2">
<div class="list_text">une sous-liste devenue vide au terme des divisions successives.</div>
</li>
</ul>
<p>Nous créons la fonction correspondante :</p>
<p><span class="calculator_button" markdown="1">def recherche_dichotomique(valeur, sequence, debut, fin):</span></p>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">if debut &gt; fin:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">return False</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">milieu = (debut + fin) // 2</span><br>
<span class="calculator_button" markdown="1">if sequence[milieu] == valeur:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">return True</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">if valeur &lt; sequence[milieu]:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:100px;"><p><span class="calculator_button" markdown="1">return recherche_dichotomique(valeur, sequence, debut, milieu - 1)</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:100px;"><p><span class="calculator_button" markdown="1">return recherche_dichotomique(valeur, sequence, milieu + 1, fin)</span></p></div>
<p>Nous vérifions son bon fonctionnement :</p>
<p><span class="calculator_button" markdown="1">sequence = [3, 6, 7, 9, 15, 17, 23, 36, 42]</span><br>
<span class="calculator_button" markdown="1">print(recherche_dichotomique(9, sequence, 0, len(sequence)-1))</span><br>
<span class="calculator_button" markdown="1"># affiche True</span></p>
<p><span class="calculator_button" markdown="1">print(recherche_dichotomique(19, sequence, 0, len(sequence)-1))</span><br>
<span class="calculator_button" markdown="1"># affiche False</span></p>
<p>Cette implémentation oblige à spécifier manuellement les valeurs initiales de début et de fin de liste. Nous pouvons faire évoluer notre fonction, pour éviter à l’utilisateur·rice d’avoir à le faire, en insérant des valeurs par défaut.</p>
<p><span class="calculator_button" markdown="1">def recherche_dichotomique(valeur, sequence, debut=None, fin=None):</span></p>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">if debut is None:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">debut = 0</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">if fin is None:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">fin = len(sequence) - 1</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">if debut &gt; fin:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">return False</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">milieu = (debut + fin) // 2</span><br>
<span class="calculator_button" markdown="1">if sequence[milieu] == valeur:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">return True</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">if valeur &lt; sequence[milieu]:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:100px;"><p><span class="calculator_button" markdown="1">return recherche_dichotomique(valeur, sequence, debut, milieu-1)</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:100px;"><p><span class="calculator_button" markdown="1">return recherche_dichotomique(valeur, sequence, milieu+1, fin)</span></p></div>
<p>Avec cette modification, l’appel de fonction s’effectue en spécifiant uniquement le nombre à trouver et la liste dans laquelle le chercher.</p>
<p><span class="calculator_button" markdown="1">print(recherche_dichotomique(9, [3, 6, 7, 9, 15, 17, 23, 36, 42]))</span><br>
<span class="calculator_button" markdown="1"># affiche True</span></p>
<p>En restant dans une implémentation récursive, on pourrait aussi passer en argument la liste réduite, au lieu d’en spécifier des bornes plus restreintes par le biais des autres arguments. Néanmoins cela entraînerait la création d’autant de sous-listes qu’il y a d’appels récursifs.</p>
<p>On peut également implémenter une version itérative de la recherche dichotomique, avec une boucle <em>while</em> en remplacement des appels récursifs.</p>
<p><span class="calculator_button" markdown="1">def recherche_dichotomique(valeur, sequence):</span></p>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">debut = 0</span><br>
<span class="calculator_button" markdown="1">fin = len(sequence) - 1</span><br>
<span class="calculator_button" markdown="1">present = False</span><br>
<span class="calculator_button" markdown="1">while debut &lt;= fin and not present:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">milieu = (debut + fin) // 2</span><br>
<span class="calculator_button" markdown="1">if sequence[milieu] == valeur:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">present = True</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">if valeur &lt; sequence[milieu]:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:100px;"><p><span class="calculator_button" markdown="1">fin = milieu - 1</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:100px;"><p><span class="calculator_button" markdown="1">debut = milieu + 1</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">return present</span></p></div>
<p><span class="calculator_button" markdown="1">print(recherche_dichotomique(9, [3, 6, 7, 9, 15, 17, 23, 36, 42]))</span><br>
<span class="calculator_button" markdown="1"># affiche True</span></p>
<p><span class="calculator_button" markdown="1">print(recherche_dichotomique(41, [3, 6, 7, 9, 15, 17, 23, 36, 42]))</span><br>
<span class="calculator_button" markdown="1"># affiche False</span></p>
<p>On notera que l’élimination des sous-listes non pertinentes à chaque étape de la recherche dichotomique, nous a dispensé d’un traitement de recombinaison puisque nous aboutissons à un <b>résultat unique</b>. Nous allons montrer la nécessité de la recombinaison avec le cas d’étude suivant, celui du tri-fusion.</p>
<h2 range="3" markdown="1"><div markdown="1"><p>Tri-fusion</p></div></h2>
<h3 range="a." markdown="1"><div markdown="1"><p>Principe général</p></div></h3>
<div class="blocks definition" markdown="1">
<div class="blocks-icon">
<img src="/content/images/definition.svg" alt="bannière definition">
<p>Définition</p>
</div>
<div class="blocks-text" markdown="1">
<p><b>Tri-fusion :</b></p>
<p>Le principe du tri-fusion consiste à trier une liste de la manière suivante : on la divise récursivement en deux sous-listes. Les sous-listes sont ensuite triées puis fusionnées entre elles.</p>
</div>
</div>
<p>Le <b>tri-fusion</b> (ou tri par fusion) est parfois aussi appelé « tri par interclassement ». La comparaison des algorithmes de tri sort du cadre de ce cours, mais on retiendra que le tri-fusion : </p>
<ul>

<li class="liste2">
<div class="list_text">présente une complexité de $O(n log (n))$ ;</div>
</li>

<li class="liste2">
<div class="list_text">fait partie des algorithmes de tri dont la complexité est constante dans tous les cas de figure, c’est-à-dire qu’elle reste du même ordre en moyenne, dans le meilleur et dans le pire des cas.</div>
</li>
</ul>
<h3 range="b." markdown="1"><div markdown="1"><p>Décomposition des étapes</p></div></h3>
<p>Commençons par un cas très simple pour bien comprendre la décomposition des étapes.<br>
Nous considérons une liste de quatre éléments <span class="calculator_button" markdown="1">[4, 2, 1, 3]</span>, que nous souhaitons trier en appliquant le tri-fusion s’appuyant sur la méthode « diviser pour régner ». </p>
<p>Les trois étapes sont :</p>
<div markdown="1" class="paragraph" style="width:90%; margin-top:0px;margin-right:auto;margin-bottom:0px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style="" range="1"></div>
<div class="list_text">diviser ;</div>
</li>
</ul></div>
<div markdown="1" class="paragraph" style="width:90%; margin-top:0px;margin-right:auto;margin-bottom:0px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style="" range="2"></div>
<div class="list_text">régner,</div>
</li>
</ul></div>
<div markdown="1" class="paragraph" style="width:90%; margin-top:0px;margin-right:auto;margin-bottom:50px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style="" range="3"></div>
<div class="list_text">combiner.</div>
</li>
</ul></div>
<ul>

<li class="bullet_list">
<div style="" range="1"></div>
<div class="list_text">Nous effectuons dans un premier temps des divisions successives :</div>
</li>

<li class="liste2">
<div class="list_text">la liste <span class="calculator_button" markdown="1">[4, 2, 1, 3]</span> est divisée en deux listes distinctes : <span class="calculator_button" markdown="1">[4, 2]</span> et <span class="calculator_button" markdown="1">[1, 3]</span> ;</div>
</li>

<li class="liste2">
<div class="list_text">chacune des listes obtenues précédemment est encore divisée ;</div>
</li>

<li class="liste2">
<div class="list_text">pour obtenir quatre listes distinctes : <span class="calculator_button" markdown="1">[4]</span>, <span class="calculator_button" markdown="1">[2]</span>, <span class="calculator_button" markdown="1">[1]</span> et <span class="calculator_button" markdown="1">[3]</span>.</div>
</li>

<li class="bullet_list">
<div style="" range="2"></div>
<div class="list_text">Quand les listes ne contiennent plus qu’un élément, nous atteignons l’étape « régner » qui nous permet de résoudre facilement les sous-problèmes : en effet une liste comprenant un seul élément est nécessairement triée.</div>
</li>

<li class="bullet_list">
<div style="" range="3"></div>
<div class="list_text">Nous devons maintenant combiner les résultats obtenus pour chaque niveau de division.<br>
Les listes individuelles sont fusionnées deux par deux, en ordonnant leurs contenus :</div>
</li>

<li class="liste2">
<div class="list_text">
<span class="calculator_button" markdown="1">[4]</span> et <span class="calculator_button" markdown="1">[2]</span> sont fusionnés en <span class="calculator_button" markdown="1">[2,4]</span>, et parallèlement <span class="calculator_button" markdown="1">[1]</span> et <span class="calculator_button" markdown="1">[3]</span> sont fusionnés en <span class="calculator_button" markdown="1">[1,3]</span> ;</div>
</li>

<li class="liste2">
<div class="list_text">les listes <span class="calculator_button" markdown="1">[2,4]</span> et <span class="calculator_button" markdown="1">[1,3]</span> sont finalement fusionnées en <span class="calculator_button" markdown="1">[1,2,3,4]</span>.</div>
</li>
</ul>
<h3 range="c." markdown="1"><div markdown="1"><p>Implémentation</p></div></h3>
<p>La division en sous-listes s’effectue sur la même base que pour la recherche dichotomique, à ceci près que tous les sous-problèmes seront traités à l’issue des divisions.</p>
<p>La partie « régner » correspond au cas de base ou cas terminal des appels récursifs, et repose sur le fait qu’une liste composée d’un seul élément est nécessairement triée. C’est également vrai pour une liste vide, et nous devrons prévoir ce cas de figure pour le traitement de listes comprenant un nombre impair de nombres.</p>
<p>La recombinaison des solutions individuelles par fusion de ces dernières constitue le point-clé qui a donné son nom à l’algorithme tri-fusion. Les listes triées doivent, en effet, être rassemblées <b>deux à deux</b> pour chaque niveau de division. La fusion s’applique à deux listes triées, qui doivent être fusionnées de manière à former une liste unique triée.</p>
<p>Commençons par implémenter une fonction réalisant cette fusion entre deux listes individuellement triées par ordre croissant :</p>
<p><span class="calculator_button" markdown="1">def fusionne(liste1, liste2):</span></p>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">liste_fusionnee = []</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">i, j = 0, 0</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">while i &lt; len(liste1) and j &lt; len(liste2):</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">if liste1[i] &lt;= liste2[j]:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">liste_fusionnee.append(liste1[i])</span><br>
<span class="calculator_button" markdown="1">i += 1</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:90px;"><p><span class="calculator_button" markdown="1">liste_fusionnee.append(liste2[j])</span><br>
<span class="calculator_button" markdown="1">j += 1</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">while i &lt; len(liste1):</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">liste_fusionnee.append(liste1[i])</span><br>
<span class="calculator_button" markdown="1">i += 1</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">while j &lt; len(liste2):</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">liste_fusionnee.append(liste2[j])</span><br>
<span class="calculator_button" markdown="1">j += 1</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">return liste_fusionnee</span></p></div>
<p>On utilise des index, matérialisés par les variables <span class="calculator_button" markdown="1">i</span> et <span class="calculator_button" markdown="1">j</span>, pour repérer la progression dans le parcours séquentiel des listes. Les éléments courants de chaque liste sont comparés et seul le plus petit des deux est ajouté à la liste fusionnée.</p>
<p>La première boucle <span class="calculator_button" markdown="1">while</span> est exécutée tant qu’aucune liste n’a été parcourue en totalité. Les deux boucles suivantes ont pour objet l’ajout à la liste fusionnée des valeurs non encore utilisées de la seule des deux listes qui n’a pas été parcourue en totalité à ce stade. </p>
<p>Nous testons cette fonction de tri avec deux listes individuelles triées.</p>
<p><span class="calculator_button" markdown="1">print(fusionne([1, 3, 5, 8], [2, 4, 6, 7]))</span><br>
<span class="calculator_button" markdown="1"># affiche [1, 2, 3, 4, 5, 6, 7, 8]</span></p>
<p>Nous vérifions que la fonction est également en mesure de fusionner des listes comprenant des doublons.</p>
<p><span class="calculator_button" markdown="1">print(fusionne([1, 3, 5, 7], [1, 2, 5, 7]))</span><br>
<span class="calculator_button" markdown="1"># affiche [1, 1, 2, 3, 5, 5, 7, 7]</span></p>
<p>Nous vérifions, par ailleurs, que la fonction est également en mesure de fusionner des listes de longueurs inégales, afin d’être en mesure de traiter des paires de listes issues de divisions d’une liste de longueur impaire.</p>
<p><span class="calculator_button" markdown="1">print(fusionne([1, 3, 6, 8], [2, 5, 7]))</span><br>
<span class="calculator_button" markdown="1"># affiche [1, 2, 3, 5, 6, 7, 8]</span></p>
<p>Définissons maintenant la fonction principale de tri-fusion. Elle effectue des appels récursifs jusqu’à atteindre des listes contenant au plus un seul élément. Elle combine ensuite les résultats issus des divisions récursives à l’aide de la fonction de fusion créée précédemment.</p>
<div class="columns" markdown="1">
<div markdown="1" class="undefined" style="width:50%; ">
<p><span class="calculator_button" markdown="1">def tri_fusion(liste):</span></p>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">if len(liste) &lt; 2:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">return liste</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">milieu = len(liste) // 2</span><br>
<span class="calculator_button" markdown="1">premiere_sous_liste = tri_fusion(liste[:milieu])</span><br>
<span class="calculator_button" markdown="1">seconde_sous_liste = tri_fusion(liste[milieu:])</span><br>
<span class="calculator_button" markdown="1">return fusionne(premiere_sous_liste, seconde_sous_liste)</span></p></div>
</div>
<div markdown="1" class="undefined" style="width:50%; "><div markdown="1" class="paragraph" style="width:100%; margin-top:100px;margin-right:auto;margin-bottom:0px;margin-left:auto;"><ul>




<li>Diviser : création des deux sous-listes (« premiere_sous_liste » et « seconde_sous_liste »)</li>




<li>Régner : tri fusion sur chaque sous-liste (appel fonction « tri_fusion »)</li>




<li>Combiner : fusion des résultats issus du tri-fusion de chaque sous-liste (appel fonction « fusionne »</li>
</ul></div></div>
</div>
<p>Testons notre fonction avec une liste non triée :</p>
<p><span class="calculator_button" markdown="1">print(tri_fusion([3, 2, 5, 9, 7, 8]))</span><br>
<span class="calculator_button" markdown="1"># affiche [2, 3, 5, 7, 8, 9]</span></p>
<p>Nous obtenons bien une liste triée par ordre croissant. Effectuons un autre test avec une liste de longueur impaire :</p>
<p><span class="calculator_button" markdown="1">print(tri_fusion([3, 2, 5, 10, 9, 7, 8]))</span><br>
<span class="calculator_button" markdown="1"># affiche [2, 3, 5, 7, 8, 9, 10]</span></p>
<p>Notre fonction de tri-fusion gère correctement les listes de longueur impaire.</p>
<div class="conclusion" markdown="1">
<p>Conclusion :</p>
<p>Nous avons présenté et caractérisé la méthode « diviser pour régner », une approche de résolution de problèmes basée sur la décomposition d’un problème complexe en sous-problèmes indépendants plus faciles à résoudre, dont les solutions individuelles sont ensuite recombinées pour résoudre le problème général.<br>
Nous avons ensuite étudié deux algorithmes rattachés à la méthode "diviser pour régner" : d’abord la recherche dichotomique dans un ensemble déjà trié, puis le tri-fusion, un algorithme fusionnant des listes individuelles obtenues par divisions successives d’une liste initiale pour trier celle-ci.</p>
</div>
</div></div>
<div id="poool-nmlpl-4m80w" class="poool-widget"></div>
</div>
</div>
<div></div>
</div></main><footer class="footer-module_footer__YIYIL footer-module_footer__grid__C-ZCT"></footer>
</div>
</div>
<script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"sheetTemplateProps":{"resource":{"resourceId":"5f2c13165e6c630100f7efbe","type":"Cours","title":"Diviser pour régner","content":"[IN]\nIntroduction\u0026nbsp;:\n\nLa méthode «\u0026nbsp;diviser pour régner\u0026nbsp;» est une approche de résolution de problèmes qui consiste à décomposer un problème complexe en sous-problèmes plus faciles à traiter afin de résoudre le problème initial.\n\nNous allons dans un premier temps définir et caractériser la méthode «\u0026nbsp;diviser pour régner\u0026nbsp;». Nous étudierons ensuite son application avec deux algorithmes mettant en œuvre ce paradigme\u0026nbsp;: la recherche dichotomique et le tri-fusion.\n[/IN]\n\n##Principes généraux/1\n\n###Origine et applications/a.\n\n* La **méthode du tri-fusion**, appliquant le principe «\u0026nbsp;diviser pour régner\u0026nbsp;», a été inventée en\u0026nbsp;1945 par le mathématicien et informaticien américano-hongrois John von\u0026nbsp;Neumann.\n* La **méthode algorithmique** «\u0026nbsp;diviser pour régner\u0026nbsp;» a été formalisée en\u0026nbsp;1946 pour la recherche dichotomique par le physicien américain John William Mauchly.\n\nMais les principes algorithmiques de type «\u0026nbsp;diviser pour régner\u0026nbsp;» sont eux-mêmes beaucoup plus anciens. Plusieurs siècles avant notre ère, les Babyloniens avaient conceptualisé cette méthode pour faciliter la recherche parmi un ensemble de dates ordonnées chronologiquement.  \nL’algorithme d’Euclide constitue un autre exemple d’approche «\u0026nbsp;diviser pour régner\u0026nbsp;».\n\n[DEF]\n**Méthode «\u0026nbsp;diviser pour régner\u0026nbsp;»\u0026nbsp;:**\n\nLe paradigme de programmation «\u0026nbsp;diviser pour régner\u0026nbsp;» consiste à décomposer un problème général en petits sous-problèmes plus simples à résoudre, permettant par recomposition d’aboutir à la résolution du problème général.\n[/DEF]\n\nCette méthode est appelée ainsi en référence à sa désignation anglaise\u0026nbsp;: __divide and conquer__.\n\n###Principales caractéristiques/b.\n\nLe paradigme de programmation «\u0026nbsp;diviser pour régner\u0026nbsp;» nécessite que le problème à résoudre soit décomposable en sous-problèmes, cette décomposition pouvant être récursive. Il s’agit d’une approche de haut en bas, également appelée **approche descendante**.\n\n[ATT]\nLa décomposition du problème en sous-problèmes est également pratiquée dans le cadre du paradigme de programmation dynamique qui fait l’objet d’un cours distinct.  \nLa principale différence entre les deux approches réside dans l’indépendance ou non des sous-problèmes\u0026nbsp;:\n* dans le paradigme «\u0026nbsp;diviser pour régner\u0026nbsp;» les problèmes sont différents les uns des autres, ils ne se répètent pas\u0026nbsp;;((liste2))\n* dans le paradigme de programmation dynamique, les sous-problèmes ne sont pas tous, ils se chevauchent.((liste2))\n[/ATT]\n\nL’approche «\u0026nbsp;diviser pour régner\u0026nbsp;» comporte trois\u0026nbsp;étapes\u0026nbsp;: **diviser**, **régner** et **combiner**. Seules les deux premières étapes sont explicitées dans la dénomination du paradigme «\u0026nbsp;diviser pour régner\u0026nbsp;», mais une étape de combinaison des solutions aux sous-problèmes est nécessaire pour aboutir à la résolution du problème général.  \nÉtudions plus précisément chacune de ces trois étapes.\n\n###Étapes/c.\n\n[RETENIR]\nL’ordre des étapes est le suivant\u0026nbsp;:\n* diviser((bulle,1))\n* régner((bulle,2))\n* combiner((bulle,3))\n[/RETENIR]\n\nLe schéma de principe ci-après permet de visualiser l’articulation des étapes successives.\n\n[IMG]((85))\n![Étapes du paradigme de programmation diviser pour régner](https://images-schoolmouv-cours.s3.eu-west-1.amazonaws.com/t-fnx-nsi-c18-img01.png) #Étapes du paradigme de programmation «\u0026nbsp;diviser pour régner\u0026nbsp;»\n[/IMG]\n\n* L’étape «\u0026nbsp;diviser\u0026nbsp;» (__divide__ en anglais) consiste à décomposer le problème principal en sous-problèmes.((bulle,1))\n* L’étape «\u0026nbsp;régner\u0026nbsp;» (ou «\u0026nbsp;conquérir\u0026nbsp;» pour __conquer__ en anglais) consiste à résoudre individuellement chacun des sous-problèmes.((bulle,2))\n* L’étape «\u0026nbsp;combiner\u0026nbsp;» (ou «\u0026nbsp;recombiner\u0026nbsp;») consiste à fusionner l'ensemble des résultats obtenus pour chacun des sous-problèmes afin d’obtenir en résultat final la solution du problème général initialement posé.((bulle,3))\n\nCes sous-problèmes peuvent eux-mêmes être décomposés en sous-problèmes selon une logique récursive. En cas de divisions multiples, il y aura, après les résolutions des sous-problèmes individuels, autant d’étapes de recombinaison qu’il y a eu d’étapes de division.\n\nLe schéma ci-après illustre le processus avec plusieurs niveaux de divisions et de recombinaisons.\n\n[IMG]((100))\n![paradigme de programmation diviser pour régner](https://images-schoolmouv-cours.s3.eu-west-1.amazonaws.com/t-fnx-nsi-c18-img02.png) #Paradigme de programmation «\u0026nbsp;diviser pour régner\u0026nbsp;» avec plusieurs niveaux de division et de combinaison\n[/IMG]\n\n* Le schéma montre que chaque problème ou sous-problème est décomposé en deux sous-problèmes. Cette division par deux est la plus fréquente, mais la méthode pourrait s’appliquer avec une décomposition en un nombre plus important de sous-problèmes d’un même niveau.((fleche))\n\n[RETENIR]\nLors de la décomposition de problèmes en sous-problèmes, on fait en sorte que les sous-problèmes soient, dans la mesure du possible, de tailles comparables. \n[/RETENIR]\nL’**implémentation récursive** est généralement privilégiée dans ce contexte, mais il est également possible de réaliser des **implémentations itératives** de la méthode «\u0026nbsp;diviser pour régner\u0026nbsp;».\n\nMaintenant que nous avons défini les principales caractéristiques de cette méthode algorithmique, nous allons en étudier deux\u0026nbsp;applications, d’abord la **recherche dichotomique**, puis le **tri-fusion**.\n\n##Recherche dichotomique/2\n\n###Principes généraux/a.\n\n[DEF]\n**Recherche dichotomique\u0026nbsp;:**\n\nLa recherche dichotomique consiste à vérifier si un élément est présent dans un ensemble ordonné. Cette recherche par dichotomie est parfois appelée «\u0026nbsp;fouille dichotomique\u0026nbsp;» ou encore «\u0026nbsp;recherche binaire\u0026nbsp;». \n[/DEF]\n\nOn utilise couramment cette méthode, sans nécessairement en connaître le nom\u0026nbsp;: chaque fois que l’on cherche un mot dans un dictionnaire par exemple, ou lorsqu’on nous propose de deviner un nombre.\n\n[EX]\nSi on nous demande de deviner un nombre entre $1$ et $100$, on va commencer par proposer $50$. Si c’est moins, on sait que le nombre est à chercher entre $1$ et $49$ et on proposera $25$. Si c’est plus de $25$, on proposera $37$, là encore pour être à peu près à la moitié de l’intervalle entre $26$ et $49$. Et ainsi de suite jusqu’à trouver le nombre mystère.\n[/EX]\n\nAinsi, on tend vers l’élément **médian** de l’ensemble considéré. Si ce n’est pas l’élément recherché, on poursuit la recherche dans la première ou dans la seconde partie de l’ensemble, en fonction du résultat de la comparaison entre l’élément recherché et l’élément médian auquel on l’a comparé\u0026nbsp;:\n* si l’élément médian est supérieur à l’élément recherché, l’élément recherché est nécessairement dans la première partie de l’ensemble\u0026nbsp;;((liste2))\n* si l’élément médian est inférieur à l’élément recherché, l’élément recherché est nécessairement dans la seconde partie de l’ensemble.((liste2))\n* On applique cette même logique à chaque sous-partie jusqu’à trouver l’élément recherché, s’il est présent.((fleche))\n\nCette méthode très simple est aussi très efficace. On élimine en effet chaque fois la moitié de l’ensemble des possibles. La réduction est donc très rapide, même pour de grands ensembles. La complexité de l’algorithme de recherche dichotomique est $O(log(n))$.\n\n[ATT]\nLa méthode de recherche dichotomique s’effectue nécessairement sur un ensemble de données préalablement **triées**, conventionnellement par ordre croissant. La méthode s’appuie en effet sur l’ordre de classement des éléments pour pouvoir en éliminer la moitié à chaque étape.\n[/ATT]\n\nNous allons réaliser une implémentation de recherche dichotomique pour indiquer si un nombre est, ou non, présent dans une liste triée de nombres entiers.  \nIl convient ici de préciser que la recherche dichotomique est généralement rattachée au paradigme «\u0026nbsp;diviser pour régner\u0026nbsp;», mais avec la particularité de ne pas résoudre tous les sous-problèmes, puisque la moitié du problème est éliminée à chaque étape, ainsi que nous allons l’illustrer en décomposant ces étapes avec un exemple.\n\n###Décomposition des étapes/b.\n\nNous disposons d’une séquence de nombre entiers triés par ordre croissant\u0026nbsp;: $3$, $6$, $7$, $9$, $15$, $17$, $23$, $36$, $42$. Nous souhaitons vérifier si le nombre $9$ est présent dans cette liste en utilisant la recherche dichotomique.\n\n[IMG]((100))\n![recherche dichotomique](https://images-schoolmouv-cours.s3.eu-west-1.amazonaws.com/t-fnx-nsi-c18-img03.png) #Étapes successives de traitement sur la séquence de nombres\n[/IMG]\n\nÀ chaque étape du processus nous déterminons le milieu de la liste, qui est comparé au nombre recherché pour éliminer la demi-liste qui ne peut pas le contenir. On continue jusqu’à le trouver, s’il est présent, ou à constater son absence.\n\nDans notre illustration, le nombre $9$ est présent. Il devient l’élément milieu lors de l’étape où la liste est réduite à un seul élément. Si nous avions recherché le nombre $8$, nous aurions constaté à ce stade son absence.\n\nNous avons présenté les étapes aboutissant aux deux cas de base possibles\u0026nbsp;:\n* la présence du nombre recherché\u0026nbsp;;((liste2))\n* l’absence du nombre recherché.((liste2))\n\nConstater l’absence du nombre recherché nécessite d’aller jusqu’au bout des divisions possibles de la liste de départ. En revanche la découverte du nombre recherché peut s’avérer beaucoup plus rapide\u0026nbsp;:\n* il suffit d’une seule division pour ensuite découvrir le nombre $6$ figurant au milieu de la demi-liste conservée\u0026nbsp;;((liste2))\n* aucune division n’est nécessaire pour découvrir le nombre $15$ puisqu’il est situé au milieu de la liste de départ.((liste2))\n\n###Implémentation/c.\n\nL’implémentation récursive est une transposition assez littérale des étapes que nous venons d’illustrer.  \nLes deux cas de base possibles sont\u0026nbsp;:\n* la découverte du nombre cherché, qui peut survenir à tout moment\u0026nbsp;;((liste2))\n* une sous-liste devenue vide au terme des divisions successives.((liste2))\n\nNous créons la fonction correspondante\u0026nbsp;:\n\n[BUTC]def recherche_dichotomique(valeur, sequence, debut, fin):[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]if debut \u003e fin:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]return False[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]milieu = (debut + fin) // 2[/BUTC]  \n[BUTC]if sequence[milieu] == valeur:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]return True[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]if valeur \u003c sequence[milieu]:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,100))[BUTC]return recherche_dichotomique(valeur, sequence, debut, milieu - 1)[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,100))[BUTC]return recherche_dichotomique(valeur, sequence, milieu + 1, fin)[/BUTC]\u003e\u003e\n\nNous vérifions son bon fonctionnement\u0026nbsp;:\n\n[BUTC]sequence = [3, 6, 7, 9, 15, 17, 23, 36, 42][/BUTC]  \n[BUTC]print(recherche_dichotomique(9, sequence, 0, len(sequence)-1))[/BUTC]  \n[BUTC]# affiche True[/BUTC]\n\n[BUTC]print(recherche_dichotomique(19, sequence, 0, len(sequence)-1))[/BUTC]  \n[BUTC]# affiche False[/BUTC]\n\nCette implémentation oblige à spécifier manuellement les valeurs initiales de début et de fin de liste. Nous pouvons faire évoluer notre fonction, pour éviter à l’utilisateur·rice d’avoir à le faire, en insérant des valeurs par défaut.\n\n[BUTC]def recherche_dichotomique(valeur, sequence, debut=None, fin=None):[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]if debut is None:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]debut = 0[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]if fin is None:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]fin = len(sequence) - 1[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]if debut \u003e fin:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]return False[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]milieu = (debut + fin) // 2[/BUTC]  \n[BUTC]if sequence[milieu] == valeur:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]return True[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]if valeur \u003c sequence[milieu]:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,100))[BUTC]return recherche_dichotomique(valeur, sequence, debut, milieu-1)[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,100))[BUTC]return recherche_dichotomique(valeur, sequence, milieu+1, fin)[/BUTC]\u003e\u003e\n\nAvec cette modification, l’appel de fonction s’effectue en spécifiant uniquement le nombre à trouver et la liste dans laquelle le chercher.\n\n[BUTC]print(recherche_dichotomique(9, [3, 6, 7, 9, 15, 17, 23, 36, 42]))[/BUTC]  \n[BUTC]# affiche True[/BUTC]\n\nEn restant dans une implémentation récursive, on pourrait aussi passer en argument la liste réduite, au lieu d’en spécifier des bornes plus restreintes par le biais des autres arguments. Néanmoins cela entraînerait la création d’autant de sous-listes qu’il y a d’appels récursifs.\n\nOn peut également implémenter une version itérative de la recherche dichotomique, avec une boucle __while__ en remplacement des appels récursifs.\n\n[BUTC]def recherche_dichotomique(valeur, sequence):[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]debut = 0[/BUTC]  \n[BUTC]fin = len(sequence) - 1[/BUTC]  \n[BUTC]present = False[/BUTC]  \n[BUTC]while debut \u003c= fin and not present:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]milieu = (debut + fin) // 2[/BUTC]  \n[BUTC]if sequence[milieu] == valeur:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]present = True[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]if valeur \u003c sequence[milieu]:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,100))[BUTC]fin = milieu - 1[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,100))[BUTC]debut = milieu + 1[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]return present[/BUTC]\u003e\u003e\n\n[BUTC]print(recherche_dichotomique(9, [3, 6, 7, 9, 15, 17, 23, 36, 42]))[/BUTC]  \n[BUTC]# affiche True[/BUTC]\n\n[BUTC]print(recherche_dichotomique(41, [3, 6, 7, 9, 15, 17, 23, 36, 42]))[/BUTC]  \n[BUTC]# affiche False[/BUTC]\n\nOn notera que l’élimination des sous-listes non\u0026nbsp;pertinentes à chaque étape de la recherche dichotomique, nous a dispensé d’un traitement de recombinaison puisque nous aboutissons à un **résultat unique**. Nous allons montrer la nécessité de la recombinaison avec le cas d’étude suivant, celui du tri-fusion.\n\n##Tri-fusion/3\n\n###Principe général/a.\n\n[DEF]\n**Tri-fusion\u0026nbsp;:**\n\nLe principe du tri-fusion consiste à trier une liste de la manière suivante\u0026nbsp;: on la divise récursivement en deux sous-listes. Les sous-listes sont ensuite triées puis fusionnées entre elles.\n[/DEF]\n\nLe **tri-fusion** (ou tri par fusion) est parfois aussi appelé «\u0026nbsp;tri par interclassement\u0026nbsp;». La comparaison des algorithmes de tri sort du cadre de ce cours, mais on retiendra que le tri-fusion\u0026nbsp;: \n* présente une complexité de $O(n log (n))$ ;((liste2))\n* fait partie des algorithmes de tri dont la complexité est constante dans tous les cas de figure, c’est-à-dire qu’elle reste du même ordre en moyenne, dans le meilleur et dans le pire des cas.((liste2))\n\n###Décomposition des étapes/b.\n\nCommençons par un cas très simple pour bien comprendre la décomposition des étapes.  \nNous considérons une liste de quatre éléments [BUTC][4, 2, 1, 3][/BUTC], que nous souhaitons trier en appliquant le tri-fusion s’appuyant sur la méthode «\u0026nbsp;diviser pour régner\u0026nbsp;». \n\nLes trois étapes sont\u0026nbsp;:\n\u003c\u003c((90,0,auto,0,auto))* diviser\u0026nbsp;;((bulle,1))\u003e\u003e\n\u003c\u003c((90,0,auto,0,auto))* régner,((bulle,2))\u003e\u003e\n\u003c\u003c((90,0,auto,50,auto))* combiner.((bulle,3))\u003e\u003e\n* Nous effectuons dans un premier temps des divisions successives\u0026nbsp;:((bulle,1))\n* la liste [BUTC][4, 2, 1, 3][/BUTC] est divisée en deux listes distinctes\u0026nbsp;: [BUTC][4, 2][/BUTC] et [BUTC][1, 3][/BUTC]\u0026nbsp;;((liste2))\n* chacune des listes obtenues précédemment est encore divisée\u0026nbsp;;((liste2))\n* pour obtenir quatre listes distinctes\u0026nbsp;: [BUTC]\u0026#91;4][/BUTC], [BUTC]\u0026#91;2][/BUTC], [BUTC]\u0026#91;1][/BUTC] et [BUTC]\u0026#91;3][/BUTC].((liste2))\n* Quand les listes ne contiennent plus qu’un élément, nous atteignons l’étape «\u0026nbsp;régner\u0026nbsp;» qui nous permet de résoudre facilement les sous-problèmes\u0026nbsp;: en effet une liste comprenant un seul élément est nécessairement triée.((bulle,2))\n* Nous devons maintenant combiner les résultats obtenus pour chaque niveau de division.  \nLes listes individuelles sont fusionnées deux par deux, en ordonnant leurs contenus\u0026nbsp;:((bulle,3))\n* [BUTC][4][/BUTC] et [BUTC][2][/BUTC] sont fusionnés en [BUTC][2,4][/BUTC], et parallèlement [BUTC][1][/BUTC] et [BUTC][3][/BUTC] sont fusionnés en [BUTC][1,3][/BUTC]\u0026nbsp;;((liste2))\n* les listes [BUTC][2,4][/BUTC] et [BUTC][1,3][/BUTC] sont finalement fusionnées en [BUTC][1,2,3,4][/BUTC].((liste2))\n\n###Implémentation/c.\n\nLa division en sous-listes s’effectue sur la même base que pour la recherche dichotomique, à ceci près que tous les sous-problèmes seront traités à l’issue des divisions.\n\nLa partie «\u0026nbsp;régner\u0026nbsp;» correspond au cas de base ou cas terminal des appels récursifs, et repose sur le fait qu’une liste composée d’un seul élément est nécessairement triée. C’est également vrai pour une liste vide, et nous devrons prévoir ce cas de figure pour le traitement de listes comprenant un nombre impair de nombres.\n\nLa recombinaison des solutions individuelles par fusion de ces dernières constitue le point-clé qui a donné son nom à l’algorithme tri-fusion. Les listes triées doivent, en effet, être rassemblées **deux à deux** pour chaque niveau de division. La fusion s’applique à deux listes triées, qui doivent être fusionnées de manière à former une liste unique triée.\n\nCommençons par implémenter une fonction réalisant cette fusion entre deux listes individuellement triées par ordre croissant\u0026nbsp;:\n\n[BUTC]def fusionne(liste1, liste2):[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]liste_fusionnee = [][/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]i, j = 0, 0[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]while i \u003c len(liste1) and j \u003c len(liste2):[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]if liste1[i] \u003c= liste2[j]:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]liste_fusionnee.append(liste1[i])[/BUTC]  \n[BUTC]i += 1[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,90))[BUTC]liste_fusionnee.append(liste2[j])[/BUTC]  \n[BUTC]j += 1[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]while i \u003c len(liste1):[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]liste_fusionnee.append(liste1[i])[/BUTC]  \n[BUTC]i += 1[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]while j \u003c len(liste2):[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]liste_fusionnee.append(liste2[j])[/BUTC]  \n[BUTC]j += 1[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]return liste_fusionnee[/BUTC]\u003e\u003e\n\nOn utilise des index, matérialisés par les variables [BUTC]i[/BUTC] et [BUTC]j[/BUTC], pour repérer la progression dans le parcours séquentiel des listes. Les éléments courants de chaque liste sont comparés et seul le plus petit des deux est ajouté à la liste fusionnée.\n\nLa première boucle [BUTC]while[/BUTC] est exécutée tant qu’aucune liste n’a été parcourue en totalité. Les deux boucles suivantes ont pour objet l’ajout à la liste fusionnée des valeurs non\u0026nbsp;encore utilisées de la seule des deux listes qui n’a pas été parcourue en totalité à ce stade. \n\nNous testons cette fonction de tri avec deux listes individuelles triées.\n\n[BUTC]print(fusionne([1, 3, 5, 8], [2, 4, 6, 7]))[/BUTC]  \n[BUTC]# affiche [1, 2, 3, 4, 5, 6, 7, 8][/BUTC]\n\nNous vérifions que la fonction est également en mesure de fusionner des listes comprenant des doublons.\n\n[BUTC]print(fusionne([1, 3, 5, 7], [1, 2, 5, 7]))[/BUTC]  \n[BUTC]# affiche [1, 1, 2, 3, 5, 5, 7, 7][/BUTC]\n\nNous vérifions, par ailleurs, que la fonction est également en mesure de fusionner des listes de longueurs inégales, afin d’être en mesure de traiter des paires de listes issues de divisions d’une liste de longueur impaire.\n\n[BUTC]print(fusionne([1, 3, 6, 8], [2, 5, 7]))[/BUTC]  \n[BUTC]# affiche [1, 2, 3, 5, 6, 7, 8][/BUTC]\n\nDéfinissons maintenant la fonction principale de tri-fusion. Elle effectue des appels récursifs jusqu’à atteindre des listes contenant au plus un seul élément. Elle combine ensuite les résultats issus des divisions récursives à l’aide de la fonction de fusion créée précédemment.\n\n[COLONNES][COL][BUTC]def tri_fusion(liste):[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]if len(liste) \u003c 2:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]return liste[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]milieu = len(liste) // 2[/BUTC]  \n[BUTC]premiere\u0026#95;sous\u0026#95;liste = tri\u0026#95;fusion(liste[:milieu])[/BUTC]  \n[BUTC]seconde\u0026#95;sous\u0026#95;liste = tri\u0026#95;fusion(liste[milieu:])[/BUTC]  \n[BUTC]return fusionne(premiere\u0026#95;sous\u0026#95;liste, seconde\u0026#95;sous\u0026#95;liste)[/BUTC]\u003e\u003e  \n[/COL]((50))\n[COL]\n\u003c\u003c((100,100,auto,0,auto))* Diviser : création des deux sous-listes («\u0026nbsp;premiere\u0026#95;sous\u0026#95;liste\u0026nbsp;» et «\u0026nbsp;seconde\u0026#95;sous\u0026#95;liste\u0026nbsp;»)\n* Régner : tri fusion sur chaque sous-liste (appel fonction «\u0026nbsp;tri\u0026#95;fusion\u0026nbsp;»)\n* Combiner : fusion des résultats issus du tri-fusion de chaque sous-liste (appel fonction «\u0026nbsp;fusionne\u0026nbsp;»\u003e\u003e\n[/COL]((50))[/COLONNES]\n\nTestons notre fonction avec une liste non\u0026nbsp;triée\u0026nbsp;:\n\n[BUTC]print(tri_fusion([3, 2, 5, 9, 7, 8]))[/BUTC]  \n[BUTC]# affiche [2, 3, 5, 7, 8, 9][/BUTC]\n\nNous obtenons bien une liste triée par ordre croissant. Effectuons un autre test avec une liste de longueur impaire\u0026nbsp;:\n\n[BUTC]print(tri_fusion([3, 2, 5, 10, 9, 7, 8]))[/BUTC]  \n[BUTC]# affiche [2, 3, 5, 7, 8, 9, 10][/BUTC]\n\nNotre fonction de tri-fusion gère correctement les listes de longueur impaire.\n\n[C]\nConclusion\u0026nbsp;:\n\nNous avons présenté et caractérisé la méthode «\u0026nbsp;diviser pour régner\u0026nbsp;», une approche de résolution de problèmes basée sur la décomposition d’un problème complexe en sous-problèmes indépendants plus faciles à résoudre, dont les solutions individuelles sont ensuite recombinées pour résoudre le problème général.  \nNous avons ensuite étudié deux algorithmes rattachés à la méthode \"diviser pour régner\" : d’abord la recherche dichotomique dans un ensemble déjà trié, puis le tri-fusion, un algorithme fusionnant des listes individuelles obtenues par divisions successives d’une liste initiale pour trier celle-ci.\n[/C]\n","siblings":[{"resourceId":"5f2c13165e6c630100f7efbe","type":"Cours","sort":null},{"resourceId":"5ece65be28e6370100445c84","type":"Fiche de révision","sort":null},{"resourceId":"5ee229f70deaa401009f6f46","type":"Quiz","sort":null}],"sheetDetails":{"id":"5dcd7e2628e637010043bf87","name":"Diviser pour régner"}},"breadcrumb":[{"key":"degree-5cd020dbafd5f7d98fa4ca93","label":"Tle","link":"https://www.schoolmouv.fr/terminale"},{"key":"subject-5cd1931a865e4a010069ac22","label":"Numérique et sciences informatiques","link":"https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques"},{"key":"resource-5dcd7e2628e637010043bf87","label":"Cours : Diviser pour régner","link":"https://www.schoolmouv.fr/cours/diviser-pour-regner/fiche-de-cours"}],"degreeSubjects":[{"degreeSubjectId":"5f4627021562320100b36eab","subjectId":"5b97cb5714bfaf0100c5c56d","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Allemand Terminale","slug":"allemand-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5b97cb5714bfaf0100c5c56d","name":"Allemand","slug":"allemand"}},{"degreeSubjectId":"5dc3dc2609e0a80100fdb93c","subjectId":"5b97cb6614bfaf0100c5c56f","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Enseignement moral et civique Terminale","slug":"enseignement-moral-et-civique-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5b97cb6614bfaf0100c5c56f","name":"Enseignement moral et civique","slug":"enseignement-moral-et-civique"}},{"degreeSubjectId":"5dc4328b09e0a80100fdb95f","subjectId":"54eb2633ecd525756067ef5c","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"SVT Terminale","slug":"svt-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb2633ecd525756067ef5c","name":"SVT","slug":"svt"}},{"degreeSubjectId":"5ffefde7bc595a0100f49b00","subjectId":"5fd729f0bc595a0100f47341","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Grand oral Terminale","slug":"grand-oral-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5fd729f0bc595a0100f47341","name":"Grand oral","slug":"grand-oral"}},{"degreeSubjectId":"5f4627411562320100b36f75","subjectId":"5b97cb5c14bfaf0100c5c56e","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Espagnol Terminale","slug":"espagnol-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5b97cb5c14bfaf0100c5c56e","name":"Espagnol","slug":"espagnol"}},{"degreeSubjectId":"5dcbe35228e637010043bcc8","subjectId":"5cd1931a865e4a010069ac22","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Numérique et sciences informatiques Terminale","slug":"numerique-et-sciences-informatiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd1931a865e4a010069ac22","name":"Numérique et sciences informatiques","slug":"numerique-et-sciences-informatiques"}},{"degreeSubjectId":"5d0cdbf8655d020100fcf803","subjectId":"54eb260eecd525756067ef58","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Mathématiques Terminale","slug":"mathematiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb260eecd525756067ef58","name":"Mathématiques","slug":"mathematiques"}},{"degreeSubjectId":"5dc2f39a09e0a80100fdb84f","subjectId":"54eb2621ecd525756067ef5a","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Histoire Terminale","slug":"histoire-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb2621ecd525756067ef5a","name":"Histoire","slug":"histoire"}},{"degreeSubjectId":"5d08ae6bbc3ce70100f6d50a","subjectId":"5cd19334865e4a010069ac25","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Enseignement scientifique Terminale","slug":"enseignement-scientifique-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5cd19334865e4a010069ac25","name":"Enseignement scientifique","slug":"enseignement-scientifique"}},{"degreeSubjectId":"5dc2eaa009e0a80100fdb82c","subjectId":"5cd19320865e4a010069ac23","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Humanités Terminale","slug":"humanites-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd19320865e4a010069ac23","name":"Humanités","slug":"humanites"}},{"degreeSubjectId":"5d024b33bc3ce70100f6d355","subjectId":"54eb263cecd525756067ef5d","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"SES Terminale","slug":"ses-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb263cecd525756067ef5d","name":"SES","slug":"ses"}},{"degreeSubjectId":"5f4626d31562320100b36eaa","subjectId":"5af9b34ad466a501002e96bd","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Anglais Terminale","slug":"anglais-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5af9b34ad466a501002e96bd","name":"Anglais","slug":"anglais"}},{"degreeSubjectId":"5d075b3ebc3ce70100f6d4b1","subjectId":"54eb262aecd525756067ef5b","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Géographie Terminale","slug":"geographie-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb262aecd525756067ef5b","name":"Géographie","slug":"geographie"}},{"degreeSubjectId":"5dcc234d09e0a80100fdbaf4","subjectId":"55df09d17fcdb8937c1d4dd2","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Physique-chimie Terminale","slug":"physique-chimie-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"55df09d17fcdb8937c1d4dd2","name":"Physique-chimie","slug":"physique-chimie"}},{"degreeSubjectId":"5d0759cf655d020100fcf01f","subjectId":"5cd19327865e4a010069ac24","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Géopolitique et sciences politiques Terminale","slug":"geopolitique-et-sciences-politiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd19327865e4a010069ac24","name":"Géopolitique et sciences politiques","slug":"geopolitique-et-sciences-politiques"}},{"degreeSubjectId":"5e2723f228e637010043d4b4","subjectId":"54eb2646ecd525756067ef5e","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Philosophie Terminale","slug":"philosophie-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb2646ecd525756067ef5e","name":"Philosophie","slug":"philosophie"}}],"degree":"Terminale","degreeName":"Terminale","degreeSlug":"terminale","subject":"Numérique et sciences informatiques","sheetSlug":"diviser-pour-regner","otherDegrees":["Terminale"]},"meta":{"h1":null,"url":"/cours/diviser-pour-regner/fiche-de-cours","title":"Diviser pour régner : cours de Terminale - Numérique et science","metaDescription":"SchoolMouv ® te propose ce cours sur Diviser pour régner (Terminale - Numérique et sciences informatiques) pour TOUT comprendre avec ✔️ vidéo ✔️ fiche de révision ✔️ exercices…","canonical":null},"error":""},"__N_SSP":true},"page":"/cours/[sheetSlug]/[resourceType]","query":{"sheetSlug":"diviser-pour-regner","resourceType":"fiche-de-cours"},"buildId":"7PMSe9KUa3QZbNQBS6zJb","assetPrefix":"/content","runtimeConfig":{"SCHOOLMOUV_BASE_URL":"https://www.schoolmouv.fr","SCHOOLMOUV_DOMAIN":"schoolmouv.fr","SCHOOLMOUV_OFFER_URL":"https://offres.schoolmouv.fr","SCHOOLMOUV_GTM_TAG":"GTM-55RGLG","SCHOOLMOUV_GRAPHQL_URL":"https://www.schoolmouv.fr/content/graphql","SCHOOLMOUV_GTM_ENABLE":"true","POOOL_APP_ID":"HV0P5-2T16H-JF0FQ-01JPD","POOOL_ENABLED":"true"},"isFallback":false,"gssp":true,"scriptLoader":[]}</script>
</body>
</html>
