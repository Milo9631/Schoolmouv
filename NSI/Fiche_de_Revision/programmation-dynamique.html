<html>
<head>
<meta charset="utf-8">
<title>Programmation dynamique : Fiche de révision de Terminale</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Programmation dynamique : Fiche de révision de Terminale">
<meta name="description" content="Fiche de révision SchoolMouv ® pour apprendre facilement Programmation dynamique (Terminale) ! En bonus : ✔️ vidéo ✔️ cours ✔️ exercices…">
<link rel="canonical" href="https://www.schoolmouv.fr/cours/programmation-dynamique/fiche-de-revision">
<link rel="icon" href="/content/favicon.ico">
<script id="json-ld" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://www.schoolmouv.fr","name":"Accueil"}},{"@type":"ListItem","position":2,"item":{"@id":"https://www.schoolmouv.fr/terminale","name":"Tle"}},{"@type":"ListItem","position":3,"item":{"@id":"https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques","name":"Numérique et sciences informatiques"}},{"@type":"ListItem","position":4,"item":{"@id":"https://www.schoolmouv.fr/cours/programmation-dynamique/fiche-de-cours","name":"Programmation dynamique"}},{"@type":"ListItem","position":5,"item":{"@id":"","name":"Fiche de révision : Programmation dynamique"}}]}</script><meta name="next-head-count" content="8">
<meta name="next-font-preconnect">
<link rel="preload" href="/content/_next/static/css/c08fcb46814d24f9.css" as="style">
<link rel="stylesheet" href="/content/_next/static/css/c08fcb46814d24f9.css" data-n-g="">
<link rel="preload" href="/content/_next/static/css/08a7cf401873c9c5.css" as="style">
<link rel="stylesheet" href="/content/_next/static/css/08a7cf401873c9c5.css" data-n-p="">
<noscript data-n-css=""></noscript>
<script defer nomodule="" src="/content/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/content/_next/static/chunks/webpack-76dd136e829fd452.js" defer></script><script src="/content/_next/static/chunks/framework-4556c45dd113b893.js" defer></script><script src="/content/_next/static/chunks/main-51dcb152610665c9.js" defer></script><script src="/content/_next/static/chunks/pages/_app-335f32e3eeadaa95.js" defer></script><script src="/content/_next/static/chunks/175675d1-35a00f33118876fa.js" defer></script><script src="/content/_next/static/chunks/583-0b1ac7b20f64a25b.js" defer></script><script src="/content/_next/static/chunks/931-d71cc6dae2d04401.js" defer></script><script src="/content/_next/static/chunks/pages/cours/%5BsheetSlug%5D/%5BresourceType%5D-5a97fb82aa7779c0.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_buildManifest.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_ssgManifest.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_middlewareManifest.js" defer></script>
</head>
<body>
<div id="__next">
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-55RGLG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<div class="main-layout_main-layout__5glmx">
<main id="top"><div class="main-layout-content_main-layout-content__tzGx6">
<div><div class="sheet-template_sheet-sidebar__poLNy sidebar-module_sidebar__ruXSQ"></div></div>
<div>
<div class="main-layout-content_main-layout-content__breadcrumb-with-ellipsis__23a_n breadcrumb-module_breadcrumb__r-ILp">
<a style="height:14px" href="https://www.schoolmouv.fr"></a><img height="8" width="11" src="https://images.schoolmouv.fr/assets/icons/arrow.svg" alt="arrow"><a href="https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques" class=" link-module_xxx__aw2PQ link-module_xxx--large__UT8xp link-module_xxx--default__2faDQ link-module_xxx--global__pTt-C"> <!-- -->Numérique et sciences informatiques</a><img height="8" width="11" src="https://images.schoolmouv.fr/assets/icons/arrow.svg" alt="arrow"><h1>Fiche de révision : Programmation dynamique</h1>
</div>
<div class="sheet-template_sheet__nXEoV">
<div><div class="luna-title_luna-title__kZRX8"><p>Programmation dynamique</p></div></div>
<div class="sheet-template_sheet__info-banner--container__ni_Oi"></div>
<div><div class="react-luna-container luna-content_luna-content__GPj_Y">
<h2 range="1" markdown="1"><div markdown="1"><p>Limites de la version récursivité simple</p></div></h2>
<ul>

<li>La suite de Fibonacci est à la fois un exemple classique de programmation récursive et une bonne illustration des limites de la récursivité.</li>

<li>La définition mathématique de la suite de Fibonacci se transpose très littéralement en algorithme récursif.</li>

<li>Le calcul et l’affichage des nombres sont quasiment instantanés.</li>

<li>Toutefois on constate que même pour des nombres relativement petits, le temps de calcul augmente très rapidement.</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">On peut le constater avec le calcul des nombres de Fibonacci à partir de $n = 30$.</div>
</li>

<li>Au total, calculer les 50 premiers nombres de la suite nécessite environ trois heures de calcul avec un ordinateur moderne.</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">Les temps de calcul des valeurs de la suite forment une courbe exponentielle.</div>
</li>

<li>En effet, un nombre de Fibonacci étant la somme des deux nombres qui le précèdent, son calcul fait référence à deux nombres qui doivent eux-mêmes être calculés ou retournés.</li>

<li>Si on matérialise un arbre des appels, on remarque qu’un même calcul est demandé à plusieurs reprises. Par exemple :</li>

<li class="liste2">
<div class="list_text">
<span class="calculator_button" markdown="1">fibonacci(4)</span> est appelé deux fois ;</div>
</li>

<li class="liste2">
<div class="list_text">
<span class="calculator_button" markdown="1">fibonacci(3)</span> est appelé trois fois ;</div>
</li>

<li class="liste2">
<div class="list_text">
<span class="calculator_button" markdown="1">fibonacci(2)</span> est appelé cinq fois.</div>
</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">La programmation dynamique peut nous permettre d’optimiser les appels de fonction réitérés pour une même valeur.</div>
</li>
</ul>
<h2 range="2" markdown="1"><div markdown="1"><p>Principes généraux de la programmation dynamique</p></div></h2>
<ul>

<li>La programmation dynamique est une approche de résolution de problèmes qui consiste à décomposer un problème complexe en sous-problèmes plus simples et à faire en sorte de ne résoudre qu’une seule fois chaque sous-problème quand celui-ci se répète.</li>

<li>En programmation dynamique, chaque résultat obtenu est conservé pour pouvoir être réutilisé.</li>

<li>Elle repose sur deux caractéristiques complémentaires du problème à résoudre :</li>

<li class="liste2">
<div class="list_text">la notion de sous-structure optimale ;</div>
</li>

<li class="liste2">
<div class="list_text">le chevauchement des sous-problèmes.</div>
</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">Un problème présente une sous-structure optimale si une solution optimale peut être obtenue à partir des solutions optimales de ses sous-problèmes.</div>
</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">Un problème présente des sous-problèmes récurrents s’il peut être divisé en sous-problèmes et que cette décomposition en sous-problèmes entraîne des chevauchements.</div>
</li>

<li>Notez que ce qui différencie la programmation dynamique de « diviser pour régner » c’est qu’ici les sous-problèmes ne sont pas indépendants, ils se chevauchent.</li>

<li>La mise en œuvre des principes de programmation dynamique peut s’effectuer de deux manières :</li>

<li class="bullet_list">
<div style="" range="1"></div>
<div class="list_text">approche de haut en bas (conservation des résultats des calculs après leur exécution) ;</div>
</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">Dans l’approche de haut en bas, on ne s’intéresse pas à l’ordre dans lequel les calculs ont lieu, on évite seulement de les répéter inutilement.</div>
</li>

<li class="bullet_list">
<div style="" range="2"></div>
<div class="list_text">approche de bas en haut (on part des sous-problèmes simples et on évolue de manière ascendante pour résoudre le problème global en stockant les résultats intermédiaires).</div>
</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">Dans les deux cas on utilise de l’espace mémoire pour nous permettre de réduire les temps de calculs et donc de gagner du temps.</div>
</li>
</ul>
<h2 range="3" markdown="1"><div markdown="1"><p>Application à la suite de Fibonacci</p></div></h2>
<div markdown="1" class="paragraph" style="width:100%; margin-top:50px;margin-right:auto;margin-bottom:-15px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style="" range="1"></div>
<div class="list_text"><b>Approche de haut en bas</b></div>
</li>
</ul></div>
<ul>

<li>Nous souhaitons faire évoluer notre algorithme récursif initial pour disposer d’une structure de données nous permettant de stocker les calculs à mesure qu’ils sont effectués.</li>

<li>Ainsi, lors d’un appel pour un calcul, on commencera par vérifier si la valeur a déjà été calculée :</li>

<li class="liste2">
<div class="list_text">si c’est le cas, on pourra la retourner directement à partir de la structure de données, sans avoir à lancer de nouveaux calculs ;</div>
</li>

<li class="liste2">
<div class="list_text">si la valeur n’a pas encore été calculée, les appels correspondants seront lancés comme dans notre implémentation initiale, et on ajoutera le résultat obtenu à notre structure de données afin de pouvoir l’exploiter les fois suivantes.</div>
</li>
</ul>
<p><span class="calculator_button" markdown="1">memo = {}</span></p>
<p><span class="calculator_button" markdown="1">def fibonacci(n):</span></p>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">if n in memo:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">return memo[n]</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">if n == 0:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">resultat = 0</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">elif n == 1:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">resultat = 1</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">else:</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">resultat = fibonacci(n-1) + fibonacci(n-2)</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:0px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">memo[n] = resultat</span><br>
<span class="calculator_button" markdown="1">return resultat</span></p></div>
<ul>

<li>Si on lance le calcul pour $n = 6$, le dictionnaire de données contiendra <span class="calculator_button" markdown="1"># affiche {1: 1, 0: 0, 2: 1, 3: 2, 4: 3, 5: 5, 6: 8}</span>
</li>

<li>Ainsi le calcul pour $n = 50$ qui nécessitait plus d’une heure dans notre implémentation récursive simple est désormais quasiment instantané.</li>

<li>Toutefois si on augmente les valeurs de $n$, on finit par atteindre une limite liée au nombre d’appels récursifs : il s’agit de la limite permise par défaut par l’interpréteur Python.</li>

<li>Nous avons donc réalisé une implémentation manuelle de la mémoïsation (fonctionnalité est disponible dans la bibliothèque standard de Python, avec le cache LRU de la bibliothèque <span class="calculator_button" markdown="1">functools</span>).</li>
</ul>
<div markdown="1" class="paragraph" style="width:100%; margin-top:50px;margin-right:auto;margin-bottom:-15px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style="" range="2"></div>
<div class="list_text"><b>Approche de bas en haut</b></div>
</li>
</ul></div>
<ul>

<li>On effectue les mêmes calculs que dans l’approche de haut en bas, mais en prenant en compte l’ordre dans lequel ils sont effectués.</li>

<li>Les valeurs supérieures sont calculées en séquence à partir des valeurs initiales préalablement définies ou calculées.</li>
</ul>
<p><span class="calculator_button" markdown="1">conteneur = {}</span><br>
<span class="calculator_button" markdown="1">def fibomontant(n):</span></p>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">conteneur[0] = 0</span><br>
<span class="calculator_button" markdown="1">conteneur[1] = 1</span><br>
<span class="calculator_button" markdown="1">for i in range(2, n+1):</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">resultat = conteneur[i-1] + conteneur[i-2]</span><br>
<span class="calculator_button" markdown="1">conteneur[i] = resultat</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">return resultat</span></p></div>
<p><span class="calculator_button" markdown="1">print(fibomontant(50))</span><br>
<span class="calculator_button" markdown="1"># affiche</span> (instantanément) <span class="calculator_button" markdown="1">la valeur 12586269025</span></p>
<ul>

<li>Cet algorithme n’est plus récursif mais itératif.</li>

<li>Son fonctionnement séquentiel nous permet de le simplifier davantage en se passant totalement du conteneur de données puisqu’il suffit de connaître les deux valeurs précédentes pour pouvoir calculer les suivantes.</li>
</ul>
<p><span class="calculator_button" markdown="1">def fibiteratif(n):</span></p>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">a, b = 0, 1</span><br>
<span class="calculator_button" markdown="1">for i in range(n):</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">a, b = b, a + b</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">return a</span></p></div>
</div></div>
<div id="poool-4obi9-3sulc" class="poool-widget"></div>
</div>
</div>
<div></div>
</div></main><footer class="footer-module_footer__YIYIL footer-module_footer__grid__C-ZCT"></footer>
</div>
</div>
<script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"sheetTemplateProps":{"resource":{"resourceId":"5ece74b228e6370100445c8a","type":"Fiche de révision","title":"Programmation dynamique","content":"##Limites de la version récursivité simple/1\n\n* La suite de Fibonacci est à la fois un exemple classique de programmation récursive et une bonne illustration des limites de la récursivité.\n* La définition mathématique de la suite de Fibonacci se transpose très littéralement en algorithme récursif.\n* Le calcul et l’affichage des nombres sont quasiment instantanés.\n* Toutefois on constate que même pour des nombres relativement petits, le temps de calcul augmente très rapidement.\n* On peut le constater avec le calcul des nombres de Fibonacci à partir de $n = 30$.((fleche))\n* Au total, calculer les 50\u0026nbsp;premiers nombres de la suite nécessite environ trois\u0026nbsp;heures de calcul avec un ordinateur moderne.\n* Les temps de calcul des valeurs de la suite forment une courbe exponentielle.((fleche))\n* En effet, un nombre de Fibonacci étant la somme des deux nombres qui le précèdent, son calcul fait référence à deux nombres qui doivent eux-mêmes être calculés ou retournés.\n* Si on matérialise un arbre des appels, on remarque qu’un même calcul est demandé à plusieurs reprises. Par exemple :\n* [BUTC]fibonacci(4)[/BUTC] est appelé deux fois\u0026nbsp;;((liste2))\n* [BUTC]fibonacci(3)[/BUTC] est appelé trois fois\u0026nbsp;;((liste2))\n* [BUTC]fibonacci(2)[/BUTC] est appelé cinq fois.((liste2))\n* La programmation dynamique peut nous permettre d’optimiser les appels de fonction réitérés pour une même valeur.((fleche))\n\n##Principes généraux de la programmation dynamique/2\n\n* La programmation dynamique est une approche de résolution de problèmes qui consiste à décomposer un problème complexe en sous-problèmes plus simples et à faire en sorte de ne résoudre qu’une seule fois chaque sous-problème quand celui-ci se répète.\n* En programmation dynamique, chaque résultat obtenu est conservé pour pouvoir être réutilisé.\n* Elle repose sur deux caractéristiques complémentaires du problème à résoudre\u0026nbsp;:\n* la notion de sous-structure optimale\u0026nbsp;;((liste2))\n* le chevauchement des sous-problèmes.((liste2))\n* Un problème présente une sous-structure optimale si une solution optimale peut être obtenue à partir des solutions optimales de ses sous-problèmes.((fleche))\n* Un problème présente des sous-problèmes récurrents s’il peut être divisé en sous-problèmes et que cette décomposition en sous-problèmes entraîne des chevauchements.((fleche))\n* Notez que ce qui différencie la programmation dynamique de «\u0026nbsp;diviser pour régner\u0026nbsp;» c’est qu’ici les sous-problèmes ne sont pas indépendants, ils se chevauchent.\n* La mise en œuvre des principes de programmation dynamique peut s’effectuer de deux manières\u0026nbsp;:\n* approche de haut en bas (conservation des résultats des calculs après leur exécution)\u0026nbsp;;((bulle,1))\n* Dans l’approche de haut en bas, on ne s’intéresse pas à l’ordre dans lequel les calculs ont lieu, on évite seulement de les répéter inutilement.((fleche))\n* approche de bas en haut (on part des sous-problèmes simples et on évolue de manière ascendante pour résoudre le problème global en stockant les résultats intermédiaires).((bulle,2))\n* Dans les deux cas on utilise de l’espace mémoire pour nous permettre de réduire les temps de calculs et donc de gagner du temps.((fleche))\n\n##Application à la suite de Fibonacci/3\n\n\u003c\u003c((100,50,auto,-15,auto))* **Approche de haut en bas**((bulle,1))\u003e\u003e\n\n* Nous souhaitons faire évoluer notre algorithme récursif initial pour disposer d’une structure de données nous permettant de stocker les calculs à mesure qu’ils sont effectués.\n* Ainsi, lors d’un appel pour un calcul, on commencera par vérifier si la valeur a déjà été calculée\u0026nbsp;:\n* si c’est le cas, on pourra la retourner directement à partir de la structure de données, sans avoir à lancer de nouveaux calculs\u0026nbsp;;((liste2))\n* si la valeur n’a pas encore été calculée, les appels correspondants seront lancés comme dans notre implémentation initiale, et on ajoutera le résultat obtenu à notre structure de données afin de pouvoir l’exploiter les fois suivantes.((liste2))\n\n[BUTC]memo = {}[/BUTC]\n\n[BUTC]def fibonacci(n):[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]if n in memo:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]return memo[n][/BUTC]\u003e\u003e\n    \n\u003c\u003c((auto,-22,0,0,50))[BUTC]if n == 0:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]resultat = 0[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]elif n == 1:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]resultat = 1[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]else:[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]resultat = fibonacci(n-1) + fibonacci(n-2)[/BUTC]\u003e\u003e\n        \n\u003c\u003c((auto,0,0,0,50))[BUTC]memo[n] = resultat[/BUTC]  \n[BUTC]return resultat[/BUTC]\u003e\u003e\n\n* Si on lance le calcul pour $n = 6$, le dictionnaire de données contiendra [BUTC]# affiche {1: 1, 0: 0, 2: 1, 3: 2, 4: 3, 5: 5, 6: 8}[/BUTC]\n* Ainsi le calcul pour $n = 50$ qui nécessitait plus d’une heure dans notre implémentation récursive simple est désormais quasiment instantané.\n* Toutefois si on augmente les valeurs de $n$, on finit par atteindre une limite liée au nombre d’appels récursifs\u0026nbsp;: il s’agit de la limite permise par défaut par l’interpréteur Python. \n* Nous avons donc réalisé une implémentation manuelle de la mémoïsation (fonctionnalité est disponible dans la bibliothèque standard de Python, avec le cache\u0026nbsp;LRU de la bibliothèque [BUTC]functools[/BUTC]).\n\n\u003c\u003c((100,50,auto,-15,auto))* **Approche de bas en haut**((bulle,2))\u003e\u003e\n\n* On effectue les mêmes calculs que dans l’approche de haut en bas, mais en prenant en compte l’ordre dans lequel ils sont effectués.\n* Les valeurs supérieures sont calculées en séquence à partir des valeurs initiales préalablement définies ou calculées.\n\n[BUTC]conteneur = {}[/BUTC]  \n[BUTC]def fibomontant(n):[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]conteneur[0] = 0[/BUTC]  \n[BUTC]conteneur[1] = 1[/BUTC]  \n[BUTC]for i in range(2, n+1):[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]resultat = conteneur[i-1] + conteneur[i-2][/BUTC]  \n[BUTC]conteneur[i] = resultat[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]return resultat[/BUTC]\u003e\u003e\n\n[BUTC]print(fibomontant(50))[/BUTC]  \n[BUTC]# affiche[/BUTC] (instantanément) [BUTC]la valeur 12586269025[/BUTC]\n\n* Cet algorithme n’est plus récursif mais itératif.\n* Son fonctionnement séquentiel nous permet de le simplifier davantage en se passant totalement du conteneur de données puisqu’il suffit de connaître les deux valeurs précédentes pour pouvoir calculer les suivantes.\n\n[BUTC]def fibiteratif(n):[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]a, b = 0, 1[/BUTC]  \n[BUTC]for i in range(n):[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]a, b = b, a + b[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,50))[BUTC]return a[/BUTC]\u003e\u003e\n\n","siblings":[{"resourceId":"5f2c161b5e6c630100f7efc4","type":"Cours","sort":null},{"resourceId":"5ece74b228e6370100445c8a","type":"Fiche de révision","sort":null},{"resourceId":"5f11a16f2fe66e010012b20c","type":"Quiz","sort":null}],"sheetDetails":{"id":"5dcd7e3128e637010043bf88","name":"Programmation dynamique"}},"breadcrumb":[{"key":"degree-5cd020dbafd5f7d98fa4ca93","label":"Tle","link":"https://www.schoolmouv.fr/terminale"},{"key":"subject-5cd1931a865e4a010069ac22","label":"Numérique et sciences informatiques","link":"https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques"},{"key":"resource-5dcd7e3128e637010043bf88","label":"Programmation dynamique","link":"https://www.schoolmouv.fr/cours/programmation-dynamique/fiche-de-cours"},{"key":"fiche-de-revision","label":"Fiche de révision : Programmation dynamique","link":""}],"degreeSubjects":[{"degreeSubjectId":"5f4627021562320100b36eab","subjectId":"5b97cb5714bfaf0100c5c56d","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Allemand Terminale","slug":"allemand-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5b97cb5714bfaf0100c5c56d","name":"Allemand","slug":"allemand"}},{"degreeSubjectId":"5dc3dc2609e0a80100fdb93c","subjectId":"5b97cb6614bfaf0100c5c56f","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Enseignement moral et civique Terminale","slug":"enseignement-moral-et-civique-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5b97cb6614bfaf0100c5c56f","name":"Enseignement moral et civique","slug":"enseignement-moral-et-civique"}},{"degreeSubjectId":"5dc4328b09e0a80100fdb95f","subjectId":"54eb2633ecd525756067ef5c","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"SVT Terminale","slug":"svt-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb2633ecd525756067ef5c","name":"SVT","slug":"svt"}},{"degreeSubjectId":"5ffefde7bc595a0100f49b00","subjectId":"5fd729f0bc595a0100f47341","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Grand oral Terminale","slug":"grand-oral-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5fd729f0bc595a0100f47341","name":"Grand oral","slug":"grand-oral"}},{"degreeSubjectId":"5f4627411562320100b36f75","subjectId":"5b97cb5c14bfaf0100c5c56e","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Espagnol Terminale","slug":"espagnol-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5b97cb5c14bfaf0100c5c56e","name":"Espagnol","slug":"espagnol"}},{"degreeSubjectId":"5dcbe35228e637010043bcc8","subjectId":"5cd1931a865e4a010069ac22","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Numérique et sciences informatiques Terminale","slug":"numerique-et-sciences-informatiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd1931a865e4a010069ac22","name":"Numérique et sciences informatiques","slug":"numerique-et-sciences-informatiques"}},{"degreeSubjectId":"5d0cdbf8655d020100fcf803","subjectId":"54eb260eecd525756067ef58","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Mathématiques Terminale","slug":"mathematiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb260eecd525756067ef58","name":"Mathématiques","slug":"mathematiques"}},{"degreeSubjectId":"5dc2f39a09e0a80100fdb84f","subjectId":"54eb2621ecd525756067ef5a","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Histoire Terminale","slug":"histoire-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb2621ecd525756067ef5a","name":"Histoire","slug":"histoire"}},{"degreeSubjectId":"5d08ae6bbc3ce70100f6d50a","subjectId":"5cd19334865e4a010069ac25","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Enseignement scientifique Terminale","slug":"enseignement-scientifique-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5cd19334865e4a010069ac25","name":"Enseignement scientifique","slug":"enseignement-scientifique"}},{"degreeSubjectId":"5dc2eaa009e0a80100fdb82c","subjectId":"5cd19320865e4a010069ac23","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Humanités Terminale","slug":"humanites-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd19320865e4a010069ac23","name":"Humanités","slug":"humanites"}},{"degreeSubjectId":"5d024b33bc3ce70100f6d355","subjectId":"54eb263cecd525756067ef5d","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"SES Terminale","slug":"ses-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb263cecd525756067ef5d","name":"SES","slug":"ses"}},{"degreeSubjectId":"5f4626d31562320100b36eaa","subjectId":"5af9b34ad466a501002e96bd","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Anglais Terminale","slug":"anglais-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5af9b34ad466a501002e96bd","name":"Anglais","slug":"anglais"}},{"degreeSubjectId":"5d075b3ebc3ce70100f6d4b1","subjectId":"54eb262aecd525756067ef5b","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Géographie Terminale","slug":"geographie-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb262aecd525756067ef5b","name":"Géographie","slug":"geographie"}},{"degreeSubjectId":"5dcc234d09e0a80100fdbaf4","subjectId":"55df09d17fcdb8937c1d4dd2","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Physique-chimie Terminale","slug":"physique-chimie-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"55df09d17fcdb8937c1d4dd2","name":"Physique-chimie","slug":"physique-chimie"}},{"degreeSubjectId":"5d0759cf655d020100fcf01f","subjectId":"5cd19327865e4a010069ac24","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Géopolitique et sciences politiques Terminale","slug":"geopolitique-et-sciences-politiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd19327865e4a010069ac24","name":"Géopolitique et sciences politiques","slug":"geopolitique-et-sciences-politiques"}},{"degreeSubjectId":"5e2723f228e637010043d4b4","subjectId":"54eb2646ecd525756067ef5e","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Philosophie Terminale","slug":"philosophie-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb2646ecd525756067ef5e","name":"Philosophie","slug":"philosophie"}}],"degree":"Terminale","degreeName":"Terminale","degreeSlug":"terminale","subject":"Numérique et sciences informatiques","sheetSlug":"programmation-dynamique","otherDegrees":["Terminale"]},"meta":{"h1":null,"url":"/cours/programmation-dynamique/fiche-de-revision","title":"Programmation dynamique : Fiche de révision de Terminale","metaDescription":"Fiche de révision SchoolMouv ® pour apprendre facilement Programmation dynamique (Terminale) ! En bonus : ✔️ vidéo ✔️ cours ✔️ exercices…","canonical":null},"error":""},"__N_SSP":true},"page":"/cours/[sheetSlug]/[resourceType]","query":{"sheetSlug":"programmation-dynamique","resourceType":"fiche-de-revision"},"buildId":"7PMSe9KUa3QZbNQBS6zJb","assetPrefix":"/content","runtimeConfig":{"SCHOOLMOUV_BASE_URL":"https://www.schoolmouv.fr","SCHOOLMOUV_DOMAIN":"schoolmouv.fr","SCHOOLMOUV_OFFER_URL":"https://offres.schoolmouv.fr","SCHOOLMOUV_GTM_TAG":"GTM-55RGLG","SCHOOLMOUV_GRAPHQL_URL":"https://www.schoolmouv.fr/content/graphql","SCHOOLMOUV_GTM_ENABLE":"true","POOOL_APP_ID":"HV0P5-2T16H-JF0FQ-01JPD","POOOL_ENABLED":"true"},"isFallback":false,"gssp":true,"scriptLoader":[]}</script>
</body>
</html>
