<html>
<head>
<meta charset="utf-8">
<title>Arbres et structure de données : Fiche de révision de Tle</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Arbres et structure de données : Fiche de révision de Tle">
<meta name="description" content="Fiche de révision SchoolMouv ® pour apprendre facilement Arbres et structure de données (Tle) ! En bonus : ✔️ vidéo ✔️ cours ✔️ exercices…">
<link rel="canonical" href="https://www.schoolmouv.fr/cours/arbres-et-structure-de-donnees/fiche-de-revision">
<link rel="icon" href="/content/favicon.ico">
<script id="json-ld" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://www.schoolmouv.fr","name":"Accueil"}},{"@type":"ListItem","position":2,"item":{"@id":"https://www.schoolmouv.fr/terminale","name":"Tle"}},{"@type":"ListItem","position":3,"item":{"@id":"https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques","name":"Numérique et sciences informatiques"}},{"@type":"ListItem","position":4,"item":{"@id":"https://www.schoolmouv.fr/cours/arbres-et-structure-de-donnees/fiche-de-cours","name":"Arbres et structure de données"}},{"@type":"ListItem","position":5,"item":{"@id":"","name":"Fiche de révision : Arbres et structure de données"}}]}</script><meta name="next-head-count" content="8">
<meta name="next-font-preconnect">
<link rel="preload" href="/content/_next/static/css/c08fcb46814d24f9.css" as="style">
<link rel="stylesheet" href="/content/_next/static/css/c08fcb46814d24f9.css" data-n-g="">
<link rel="preload" href="/content/_next/static/css/08a7cf401873c9c5.css" as="style">
<link rel="stylesheet" href="/content/_next/static/css/08a7cf401873c9c5.css" data-n-p="">
<noscript data-n-css=""></noscript>
<script defer nomodule="" src="/content/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/content/_next/static/chunks/webpack-76dd136e829fd452.js" defer></script><script src="/content/_next/static/chunks/framework-4556c45dd113b893.js" defer></script><script src="/content/_next/static/chunks/main-51dcb152610665c9.js" defer></script><script src="/content/_next/static/chunks/pages/_app-335f32e3eeadaa95.js" defer></script><script src="/content/_next/static/chunks/175675d1-35a00f33118876fa.js" defer></script><script src="/content/_next/static/chunks/583-0b1ac7b20f64a25b.js" defer></script><script src="/content/_next/static/chunks/931-d71cc6dae2d04401.js" defer></script><script src="/content/_next/static/chunks/pages/cours/%5BsheetSlug%5D/%5BresourceType%5D-5a97fb82aa7779c0.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_buildManifest.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_ssgManifest.js" defer></script><script src="/content/_next/static/7PMSe9KUa3QZbNQBS6zJb/_middlewareManifest.js" defer></script>
</head>
<body>
<div id="__next">
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-55RGLG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<div class="main-layout_main-layout__5glmx">
<main id="top"><div class="main-layout-content_main-layout-content__tzGx6">
<div><div class="sheet-template_sheet-sidebar__poLNy sidebar-module_sidebar__ruXSQ"></div></div>
<div>
<div class="main-layout-content_main-layout-content__breadcrumb-with-ellipsis__23a_n breadcrumb-module_breadcrumb__r-ILp">
<a style="height:14px" href="https://www.schoolmouv.fr"></a><img height="8" width="11" src="https://images.schoolmouv.fr/assets/icons/arrow.svg" alt="arrow"><a href="https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques" class=" link-module_xxx__aw2PQ link-module_xxx--large__UT8xp link-module_xxx--default__2faDQ link-module_xxx--global__pTt-C"> <!-- -->Numérique et sciences informatiques</a><img height="8" width="11" src="https://images.schoolmouv.fr/assets/icons/arrow.svg" alt="arrow"><h1>Fiche de révision : Arbres et structure de données</h1>
</div>
<div class="sheet-template_sheet__nXEoV">
<div><div class="luna-title_luna-title__kZRX8"><p>Arbres et structure de données</p></div></div>
<div class="sheet-template_sheet__info-banner--container__ni_Oi"></div>
<div><div class="react-luna-container luna-content_luna-content__GPj_Y">
<h2 range="1" markdown="1"><div markdown="1"><p>Caractérisation des arbres</p></div></h2>
<ul>

<li>Un arbre est une structure de données liant entre eux des nœuds par l’intermédiaire d’arêtes formant des branches.</li>

<li>L’organisation des nœuds d’un arbre comporte une dimension hiérarchique.</li>

<li>L’élément de base est le nœud racine d’où peuvent partir des arêtes reliant d’autres nœuds.</li>

<li>Des nœuds liés entre eux forment des branches.</li>

<li>Un nœud enfant est rattaché dans le sens ascendant à un nœud parent.</li>

<li>Un sous-arbre est une portion d’arbre à partir d’un nœud qui constitue la racine de ce sous-arbre.</li>

<li>Chaque nœud peut stocker une information, appelée valeur ou clé du nœud.</li>

<li>Les arbres informatiques sont représentés avec la racine tout en haut du schéma.</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">On dit d’une structure de données organisée comme un arbre qu’elle est « arborescente ».</div>
</li>

<li>L’organisation du système de fichiers d’un ordinateur est arborescente : les fichiers sont organisés de manière hiérarchique à partir d’une racine.</li>

<li>Il existe différentes sortes d’arbres :</li>

<li class="liste2">
<div class="list_text">les arbres généraux qui peuvent posséder un nombre de branches variable ;</div>
</li>

<li class="liste2">
<div class="list_text">les arbres binaires et les arbres binaires de recherche qui sont caractérisés par des propriétés particulières.</div>
</li>
</ul>
<div markdown="1" class="paragraph" style="width:100%; margin-top:50px;margin-right:auto;margin-bottom:-10px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style="" range="1"></div>
<div class="list_text">Arbre binaire</div>
</li>
</ul></div>
<ul>

<li>Un nœud d’un arbre binaire comporte au plus deux sous-arbres enfants appelés « gauche » et « droit ».</li>

<li>Certains nœuds non terminaux peuvent n’avoir qu’une seule branche.</li>

<li>Les branches d’un arbre ou d’un sous-arbre binaire ne sont pas nécessairement de longueurs égales.</li>
</ul>
<div markdown="1" class="paragraph" style="width:100%; margin-top:50px;margin-right:auto;margin-bottom:-10px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style="" range="2"></div>
<div class="list_text">Arbre binaire de recherche</div>
</li>
</ul></div>
<ul>

<li>Un arbre binaire de recherche est un cas particulier d’arbre binaire qui se distingue par le caractère ordonné des nœuds (donc des clés) qui le composent.</li>

<li>Le placement des clés est effectué de la façon suivante :</li>

<li class="liste2">
<div class="list_text">les valeurs situées dans le sous-arbre gauche sont nécessairement inférieures à celle de la clé du nœud considéré ;</div>
</li>

<li class="liste2">
<div class="list_text">les valeurs situées dans le sous-arbre droit sont nécessairement supérieures à celle de la clé du nœud considéré.</div>
</li>
</ul>
<div markdown="1" class="paragraph" style="width:100%; margin-top:50px;margin-right:auto;margin-bottom:-10px;margin-left:auto;"><ul>


<li>On peut mesurer la taille (nombre de nœuds) et la hauteur (nombre de nœuds parcourus sur le plus long chemin) des arbres.</li>


<li>Les structures de type arbre sont généralement implémentées en programmation objet, avec un recours fréquent à l’approche récursive pour les méthodes.</li>
</ul></div>
<h2 range="2" markdown="1"><div markdown="1"><p>Implémentations sur des arbres binaires</p></div></h2>
<ul>

<li>Notre implémentation des arbres binaires repose sur deux classes distinctes :</li>

<li class="liste2">
<div class="list_text">une classe modélisant des nœuds ;</div>
</li>

<li class="liste2">
<div class="list_text">une classe modélisant des arbres binaires à partir des nœuds.</div>
</li>
</ul>
<div markdown="1" class="paragraph" style="width:100%; margin-top:50px;margin-right:auto;margin-bottom:-10px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style=""></div>
<div class="list_text">Classe <span class="calculator_button" markdown="1">Nœud</span>
</div>
</li>
</ul></div>
<ul>

<li>La classe <span class="calculator_button" markdown="1">Noeud</span> définit des objets composés d’une valeur (la clé du nœud) et de deux branches, la gauche et la droite, identifiées par leur nœud racine .</li>

<li>Les modalités de création d’un nœud sont précisées dans la définition de la méthode spéciale <span class="calculator_button" markdown="1">__init__</span> :</li>

<li class="liste2">
<div class="list_text">seule la valeur de la clé doit être précisée au moment de la création d’un nœud ;</div>
</li>

<li class="liste2">
<div class="list_text">ses sous-branches sont initialisées avec l’objet <span class="calculator_button" markdown="1">None</span>, qui exprime l’absence de valeur.</div>
</li>

<li>La création d’un nœud s’effectue ainsi : <span class="calculator_button" markdown="1">noeud = Noeud('A')</span>.</li>

<li>Les attributs de l’objet peuvent ensuite être modifiés.</li>

<li>Pour afficher la valeur des clés gauche et droite, il suffit d'employer les commandes suivantes :<br>
<span class="calculator_button" markdown="1">print(noeud.gauche.cle)</span><br>
<span class="calculator_button" markdown="1">print(noeud.droite.cle)</span>
</li>
</ul>
<div markdown="1" class="paragraph" style="width:100%; margin-top:50px;margin-right:auto;margin-bottom:-10px;margin-left:auto;"><ul>

<li class="bullet_list">
<div style=""></div>
<div class="list_text">Classe <span class="calculator_button" markdown="1">ArbreBinaire</span>
</div>
</li>
</ul></div>
<ul>

<li>La classe <span class="calculator_button" markdown="1">ArbreBinaire</span> définit des objets composés initialement d’un nœud racine, auquel pourront être rattachés des nœuds aux différentes sous-branches.<br>
<span class="calculator_button" markdown="1">class ArbreBinaire:</span>
</li>
</ul>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:50px;"><p><span class="calculator_button" markdown="1">def __init__(self, racine):</span></p></div>
<div markdown="1" class="paragraph" style="width:auto%; margin-top:-22px;margin-right:0px;margin-bottom:0px;margin-left:75px;"><p><span class="calculator_button" markdown="1">self.racine = Noeud(racine)</span></p></div>
<ul>

<li>La création d’un arbre binaire s’effectue par initialisation de l’arbre avec un nœud racine.</li>

<li>On peut ensuite ajouter des nœuds aux branches du nœud racine, puis aux nœuds qui y sont rattachés, sans limitation de profondeur.</li>

<li>Une implémentation plus complète peut intégrer la possibilité d’ajout, de modification et de suppression de nœuds de l’arbre par des méthodes dédiées.</li>

<li>Déterminer la taille d’un arbre binaire revient à compter l’ensemble des nœuds composant cet arbre.</li>

<li>Pour déterminer la taille d’un arbre binaire, on définit la méthode <span class="calculator_button" markdown="1">taille</span> avec comme paramètres :</li>

<li class="liste2">
<div class="list_text">
<span class="calculator_button" markdown="1">self</span> qui désigne l’instance de la classe ;</div>
</li>

<li class="liste2">
<div class="list_text">le nœud à traiter.</div>
</li>

<li>L’appel initial est effectué avec une valeur par défaut correspondant au nœud racine de l’arbre.</li>

<li>Les appels suivants sont effectués de manière récursive sur les sous-arbres (leur nombre de nœuds est ajouté au nœud courant).</li>

<li>La récursion s’arrête en l’absence de nœud en sous-arbre.
Pour déterminer la hauteur d’un arbre binaire, on définit la méthode <span class="calculator_button" markdown="1">hauteur</span> avec comme paramètres :</li>

<li class="liste2">
<div class="list_text">
<span class="calculator_button" markdown="1">self</span> qui désigne l’instance de la classe ;</div>
</li>

<li class="liste2">
<div class="list_text">le nœud à traiter.</div>
</li>

<li>Les retours des appels récursifs sur les sous-branches gauches et droites sont passés en arguments à la fonction <span class="calculator_button" markdown="1">max</span>, laquelle retourne la plus grande des valeurs fournies.</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">On peut ainsi déterminer la hauteur de tout type d’arbre binaire.</div>
</li>

<li>Parcourir un arbre consiste à explorer l’ensemble de ses nœuds.</li>

<li>Il existe trois modes de parcours binaires pour effectuer cette exploration :</li>

<li class="liste2">
<div class="list_text">le parcours préfixe (nœud racine $\rightarrow$ nœud gauche $\rightarrow$ nœud droit) ;</div>
</li>

<li class="liste2">
<div class="list_text">le parcours infixe (nœud gauche$\rightarrow$ nœud racine $\rightarrow$ nœud droit) ;</div>
</li>

<li class="liste2">
<div class="list_text">le parcours suffixe (nœud gauche$\rightarrow$ nœud droit $\rightarrow$ nœud racine).</div>
</li>
</ul>
<h2 range="3" markdown="1"><div markdown="1"><p>Implémentations sur les arbres binaires de recherche</p></div></h2>
<p>Notre implémentation des arbres binaires de recherche repose sur deux classes distinctes :</p>
<ul>

<li class="liste2">
<div class="list_text">une classe modélisant des nœuds ;</div>
</li>

<li class="liste2">
<div class="list_text">une classe modélisant des arbres binaires de recherche à partir des nœuds.</div>
</li>

<li>La recherche de clé dans un arbre binaire de recherche exploite le caractère ordonné des clés.</li>

<li>Une méthode de recherche qui détermine, de manière récursive à partir du nœud racine, si la clé du nœud courant correspond ou non à la valeur recherchée, peut être définie.</li>

<li>Si la clé du nœud courant ne correspond pas, la méthode compare la clé à la valeur recherchée en évaluant si elle y est supérieure ou inférieure.</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">Les clés de l’arbre étant ordonnées, cela permet de déterminer dans quelle sous-arbre la valeur se situe nécessairement, si elle est présente dans l’arbre.</div>
</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">En d’autres termes, le caractère ordonné de l’arbre permet d’éliminer un sous-arbre sur deux à chaque étape.</div>
</li>

<li>L’ajout d’une clé dans un arbre binaire de recherche doit s’effectuer de manière à préserver le caractère ordonné des clés.</li>

<li>On effectue donc une démarche similaire à celle de la recherche, pour déterminer l’emplacement auquel la nouvelle clé doit être insérée.</li>

<li>L’implémentation doit par ailleurs s’assurer que la clé qu’on cherche à ajouter ne s’y trouve pas déjà.</li>

<li class="arrow_list">
<div style=""></div>
<div class="list_text">La méthode retourne <span class="calculator_button" markdown="1">True</span> en cas d’insertion réussie, et <span class="calculator_button" markdown="1">False</span> dans le cas contraire, c'est-à-dire le cas où la valeur est déjà présente dans l'arbre.</div>
</li>

<li>La position d’insertion de la nouvelle valeur est dictée par la propriété ordonnée de l’arbre binaire de recherche, elle n’est donc pas spécifiée par l’utilisateur·rice mais déterminée par l’algorithme.</li>

<li>Dans le cas d’un arbre binaire ou d’un arbre général, l’emplacement serait en revanche choisi par l’utilisateur·rice.</li>
</ul>
</div></div>
<div id="poool-jaaah-8u3op" class="poool-widget"></div>
</div>
</div>
<div></div>
</div></main><footer class="footer-module_footer__YIYIL footer-module_footer__grid__C-ZCT"></footer>
</div>
</div>
<script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"sheetTemplateProps":{"resource":{"resourceId":"5f48b2521f3276010020e1c2","type":"Fiche de révision","title":"Arbres et structure de données","content":"##Caractérisation des arbres/1\n\n* Un arbre est une structure de données liant entre eux des nœuds par l’intermédiaire d’arêtes formant des branches. \n* L’organisation des nœuds d’un arbre comporte une dimension hiérarchique.\n* L’élément de base est le nœud\u0026nbsp;racine d’où peuvent partir des arêtes reliant d’autres nœuds.\n* Des nœuds liés entre eux forment des branches.\n* Un nœud\u0026nbsp;enfant est rattaché dans le sens ascendant à un nœud\u0026nbsp;parent.\n* Un sous-arbre est une portion d’arbre à partir d’un nœud qui constitue la racine de ce sous-arbre.\n* Chaque nœud peut stocker une information, appelée valeur ou clé du nœud.\n* Les arbres informatiques sont représentés avec la racine tout en haut du schéma.\n* On dit d’une structure de données organisée comme un arbre qu’elle est «\u0026nbsp;arborescente\u0026nbsp;».((fleche))\n* L’organisation du système de fichiers d’un ordinateur est arborescente\u0026nbsp;: les fichiers sont organisés de manière hiérarchique à partir d’une racine.\n* Il existe différentes sortes d’arbres\u0026nbsp;:\n* les arbres généraux qui peuvent posséder un nombre de branches variable\u0026nbsp;;((liste2))\n* les arbres binaires et les arbres binaires de recherche qui sont caractérisés par des propriétés particulières.((liste2))\n\n\u003c\u003c((100,50,auto,-10,auto))\n* Arbre binaire((bulle,1))\n\u003e\u003e\n* Un nœud d’un arbre binaire comporte au plus deux sous-arbres\u0026nbsp;enfants appelés «\u0026nbsp;gauche\u0026nbsp;» et «\u0026nbsp;droit\u0026nbsp;».\n* Certains nœuds non\u0026nbsp;terminaux peuvent n’avoir qu’une seule branche.\n* Les branches d’un arbre ou d’un sous-arbre binaire ne sont pas nécessairement de longueurs égales.\n\n\u003c\u003c((100,50,auto,-10,auto))\n* Arbre binaire de recherche((bulle,2))\n\u003e\u003e\n* Un arbre binaire de recherche est un cas particulier d’arbre binaire qui se distingue par le caractère ordonné des nœuds (donc des clés) qui le composent.\n* Le placement des clés est effectué de la façon suivante\u0026nbsp;:\n* les valeurs situées dans le sous-arbre gauche sont nécessairement inférieures à celle de la clé du nœud considéré\u0026nbsp;;((liste2))\n* les valeurs situées dans le sous-arbre droit sont nécessairement supérieures à celle de la clé du nœud considéré.((liste2))\n\n\u003c\u003c((100,50,auto,-10,auto))\n* On peut mesurer la taille (nombre de nœuds) et la hauteur (nombre de nœuds parcourus sur le plus long chemin) des arbres.\n* Les structures de type arbre sont généralement implémentées en programmation objet, avec un recours fréquent à l’approche récursive pour les méthodes.\u003e\u003e\n\n##Implémentations sur des arbres binaires/2\n\n* Notre implémentation des arbres binaires repose sur deux classes distinctes\u0026nbsp;:\n* une classe modélisant des nœuds\u0026nbsp;;((liste2))\n* une classe modélisant des arbres binaires à partir des nœuds.((liste2))\n\n\u003c\u003c((100,50,auto,-10,auto))\n* Classe [BUTC]Nœud[/BUTC]((bulle))\n\u003e\u003e* La classe [BUTC]Noeud[/BUTC] définit des objets composés d’une valeur (la clé du nœud) et de deux branches, la gauche et la droite, identifiées par leur nœud\u0026nbsp;racine .\n* Les modalités de création d’un nœud sont précisées dans la définition de la méthode spéciale [BUTC]\u0026#95;\u0026#95;init\u0026#95;\u0026#95;[/BUTC]\u0026nbsp;:\n* seule la valeur de la clé doit être précisée au moment de la création d’un nœud\u0026nbsp;;((liste2))\n* ses sous-branches sont initialisées avec l’objet [BUTC]None[/BUTC], qui exprime l’absence de valeur.((liste2))\n* La création d’un nœud s’effectue ainsi\u0026nbsp;: [BUTC]noeud = Noeud('A')[/BUTC].\n* Les attributs de l’objet peuvent ensuite être modifiés.\n* Pour afficher la valeur des clés gauche et droite, il suffit d'employer les commandes suivantes\u0026nbsp;:  \n[BUTC]print(noeud.gauche.cle)[/BUTC]  \n[BUTC]print(noeud.droite.cle)[/BUTC]\n\n\n\u003c\u003c((100,50,auto,-10,auto))\n* Classe [BUTC]ArbreBinaire[/BUTC]((bulle))\n\u003e\u003e\n\n* La classe [BUTC]ArbreBinaire[/BUTC] définit des objets composés initialement d’un nœud\u0026nbsp;racine, auquel pourront être rattachés des nœuds aux différentes sous-branches.  \n[BUTC]class ArbreBinaire:[/BUTC]\n\u003c\u003c((auto,-22,0,0,50))[BUTC]def \u0026#95;\u0026#95;init\u0026#95;\u0026#95;(self, racine):[/BUTC]\u003e\u003e\n\u003c\u003c((auto,-22,0,0,75))[BUTC]self.racine = Noeud(racine)[/BUTC]\u003e\u003e\n* La création d’un arbre binaire s’effectue par initialisation de l’arbre avec un nœud\u0026nbsp;racine.\n* On peut ensuite ajouter des nœuds aux branches du nœud\u0026nbsp;racine, puis aux nœuds qui y sont rattachés, sans limitation de profondeur.\n* Une implémentation plus complète peut intégrer la possibilité d’ajout, de modification et de suppression de nœuds de l’arbre par des méthodes dédiées. \n* Déterminer la taille d’un arbre binaire revient à compter l’ensemble des nœuds composant cet arbre.\n* Pour déterminer la taille d’un arbre binaire, on définit la méthode [BUTC]taille[/BUTC] avec comme paramètres\u0026nbsp;:\n* [BUTC]self[/BUTC] qui désigne l’instance de la classe\u0026nbsp;;((liste2))\n* le nœud à traiter.((liste2))\n* L’appel initial est effectué avec une valeur par défaut correspondant au nœud\u0026nbsp;racine de l’arbre.\n* Les appels suivants sont effectués de manière récursive sur les sous-arbres (leur nombre de nœuds est ajouté au nœud\u0026nbsp;courant).\n* La récursion s’arrête en l’absence de nœud en sous-arbre.\nPour déterminer la hauteur d’un arbre binaire, on définit la méthode [BUTC]hauteur[/BUTC] avec comme paramètres\u0026nbsp;:\n* [BUTC]self[/BUTC] qui désigne l’instance de la classe\u0026nbsp;;((liste2))\n* le nœud à traiter.((liste2))\n* Les retours des appels récursifs sur les sous-branches gauches et droites sont passés en arguments à la fonction [BUTC]max[/BUTC], laquelle retourne la plus grande des valeurs fournies.\n* On peut ainsi déterminer la hauteur de tout type d’arbre binaire.((fleche))\n* Parcourir un arbre consiste à explorer l’ensemble de ses nœuds.\n* Il existe trois modes de parcours binaires pour effectuer cette exploration\u0026nbsp;:\n* le parcours préfixe (nœud\u0026nbsp;racine $\\rightarrow$ nœud gauche $\\rightarrow$ nœud droit)\u0026nbsp;;((liste2))\n* le parcours infixe (nœud gauche$\\rightarrow$ nœud\u0026nbsp;racine $\\rightarrow$ nœud droit)\u0026nbsp;;((liste2))\n* le parcours suffixe (nœud gauche$\\rightarrow$ nœud droit $\\rightarrow$ nœud\u0026nbsp;racine).((liste2))\n\n##Implémentations sur les arbres binaires de recherche/3\n\nNotre implémentation des arbres binaires de recherche repose sur deux classes distinctes\u0026nbsp;:\n* une classe modélisant des nœuds\u0026nbsp;;((liste2))\n* une classe modélisant des arbres binaires de recherche à partir des nœuds.((liste2))\n* La recherche de clé dans un arbre binaire de recherche exploite le caractère ordonné des clés.\n* Une méthode de recherche qui détermine, de manière récursive à partir du nœud racine, si la clé du nœud courant correspond ou non à la valeur recherchée, peut être définie.\n* Si la clé du nœud courant ne correspond pas, la méthode compare la clé à la valeur recherchée en évaluant si elle y est supérieure ou inférieure.\n* Les clés de l’arbre étant ordonnées, cela permet de déterminer dans quelle sous-arbre la valeur se situe nécessairement, si elle est présente dans l’arbre.((fleche))\n* En d’autres termes, le caractère ordonné de l’arbre permet d’éliminer un sous-arbre sur deux à chaque étape.((fleche))\n* L’ajout d’une clé dans un arbre binaire de recherche doit s’effectuer de manière à préserver le caractère ordonné des clés.\n* On effectue donc une démarche similaire à celle de la recherche, pour déterminer l’emplacement auquel la nouvelle clé doit être insérée.\n* L’implémentation doit par ailleurs s’assurer que la clé qu’on cherche à ajouter ne s’y trouve pas déjà.\n* La méthode retourne [BUTC]True[/BUTC] en cas d’insertion réussie, et [BUTC]False[/BUTC] dans le cas contraire, c'est-à-dire le cas où la valeur est déjà présente dans l'arbre.((fleche))\n* La position d’insertion de la nouvelle valeur est dictée par la propriété ordonnée de l’arbre binaire de recherche, elle n’est donc pas spécifiée par l’utilisateur·rice mais déterminée par l’algorithme.\n* Dans le cas d’un arbre binaire ou d’un arbre général, l’emplacement serait en revanche choisi par l’utilisateur·rice.","siblings":[{"resourceId":"5f48b0911f3276010020e1c0","type":"Cours","sort":null},{"resourceId":"5f48b2521f3276010020e1c2","type":"Fiche de révision","sort":null},{"resourceId":"5f4e1654e4d05a0100ae8464","type":"Quiz","sort":null}],"sheetDetails":{"id":"5dcd7daf09e0a80100fdbbe4","name":"Arbres et structure de données"}},"breadcrumb":[{"key":"degree-5cd020dbafd5f7d98fa4ca93","label":"Tle","link":"https://www.schoolmouv.fr/terminale"},{"key":"subject-5cd1931a865e4a010069ac22","label":"Numérique et sciences informatiques","link":"https://www.schoolmouv.fr/terminale/numerique-et-sciences-informatiques"},{"key":"resource-5dcd7daf09e0a80100fdbbe4","label":"Arbres et structure de données","link":"https://www.schoolmouv.fr/cours/arbres-et-structure-de-donnees/fiche-de-cours"},{"key":"fiche-de-revision","label":"Fiche de révision : Arbres et structure de données","link":""}],"degreeSubjects":[{"degreeSubjectId":"5f4627021562320100b36eab","subjectId":"5b97cb5714bfaf0100c5c56d","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Allemand Terminale","slug":"allemand-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5b97cb5714bfaf0100c5c56d","name":"Allemand","slug":"allemand"}},{"degreeSubjectId":"5dc3dc2609e0a80100fdb93c","subjectId":"5b97cb6614bfaf0100c5c56f","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Enseignement moral et civique Terminale","slug":"enseignement-moral-et-civique-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5b97cb6614bfaf0100c5c56f","name":"Enseignement moral et civique","slug":"enseignement-moral-et-civique"}},{"degreeSubjectId":"5dc4328b09e0a80100fdb95f","subjectId":"54eb2633ecd525756067ef5c","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"SVT Terminale","slug":"svt-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb2633ecd525756067ef5c","name":"SVT","slug":"svt"}},{"degreeSubjectId":"5ffefde7bc595a0100f49b00","subjectId":"5fd729f0bc595a0100f47341","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Grand oral Terminale","slug":"grand-oral-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5fd729f0bc595a0100f47341","name":"Grand oral","slug":"grand-oral"}},{"degreeSubjectId":"5f4627411562320100b36f75","subjectId":"5b97cb5c14bfaf0100c5c56e","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Espagnol Terminale","slug":"espagnol-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5b97cb5c14bfaf0100c5c56e","name":"Espagnol","slug":"espagnol"}},{"degreeSubjectId":"5dcbe35228e637010043bcc8","subjectId":"5cd1931a865e4a010069ac22","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Numérique et sciences informatiques Terminale","slug":"numerique-et-sciences-informatiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd1931a865e4a010069ac22","name":"Numérique et sciences informatiques","slug":"numerique-et-sciences-informatiques"}},{"degreeSubjectId":"5d0cdbf8655d020100fcf803","subjectId":"54eb260eecd525756067ef58","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Mathématiques Terminale","slug":"mathematiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb260eecd525756067ef58","name":"Mathématiques","slug":"mathematiques"}},{"degreeSubjectId":"5dc2f39a09e0a80100fdb84f","subjectId":"54eb2621ecd525756067ef5a","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Histoire Terminale","slug":"histoire-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb2621ecd525756067ef5a","name":"Histoire","slug":"histoire"}},{"degreeSubjectId":"5d08ae6bbc3ce70100f6d50a","subjectId":"5cd19334865e4a010069ac25","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Enseignement scientifique Terminale","slug":"enseignement-scientifique-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"5cd19334865e4a010069ac25","name":"Enseignement scientifique","slug":"enseignement-scientifique"}},{"degreeSubjectId":"5dc2eaa009e0a80100fdb82c","subjectId":"5cd19320865e4a010069ac23","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Humanités Terminale","slug":"humanites-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd19320865e4a010069ac23","name":"Humanités","slug":"humanites"}},{"degreeSubjectId":"5d024b33bc3ce70100f6d355","subjectId":"54eb263cecd525756067ef5d","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"SES Terminale","slug":"ses-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"54eb263cecd525756067ef5d","name":"SES","slug":"ses"}},{"degreeSubjectId":"5f4626d31562320100b36eaa","subjectId":"5af9b34ad466a501002e96bd","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Anglais Terminale","slug":"anglais-terminale","isOptional":null,"categories":["LANG"],"subjectDetails":{"id":"5af9b34ad466a501002e96bd","name":"Anglais","slug":"anglais"}},{"degreeSubjectId":"5d075b3ebc3ce70100f6d4b1","subjectId":"54eb262aecd525756067ef5b","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Géographie Terminale","slug":"geographie-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb262aecd525756067ef5b","name":"Géographie","slug":"geographie"}},{"degreeSubjectId":"5dcc234d09e0a80100fdbaf4","subjectId":"55df09d17fcdb8937c1d4dd2","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Physique-chimie Terminale","slug":"physique-chimie-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"55df09d17fcdb8937c1d4dd2","name":"Physique-chimie","slug":"physique-chimie"}},{"degreeSubjectId":"5d0759cf655d020100fcf01f","subjectId":"5cd19327865e4a010069ac24","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Géopolitique et sciences politiques Terminale","slug":"geopolitique-et-sciences-politiques-terminale","isOptional":true,"categories":[],"subjectDetails":{"id":"5cd19327865e4a010069ac24","name":"Géopolitique et sciences politiques","slug":"geopolitique-et-sciences-politiques"}},{"degreeSubjectId":"5e2723f228e637010043d4b4","subjectId":"54eb2646ecd525756067ef5e","degreeId":"5cd020dbafd5f7d98fa4ca93","name":"Philosophie Terminale","slug":"philosophie-terminale","isOptional":null,"categories":[],"subjectDetails":{"id":"54eb2646ecd525756067ef5e","name":"Philosophie","slug":"philosophie"}}],"degree":"Terminale","degreeName":"Terminale","degreeSlug":"terminale","subject":"Numérique et sciences informatiques","sheetSlug":"arbres-et-structure-de-donnees","otherDegrees":["Terminale"]},"meta":{"h1":null,"url":"/cours/arbres-et-structure-de-donnees/fiche-de-revision","title":"Arbres et structure de données : Fiche de révision de Tle","metaDescription":"Fiche de révision SchoolMouv ® pour apprendre facilement Arbres et structure de données (Tle) ! En bonus : ✔️ vidéo ✔️ cours ✔️ exercices…","canonical":null},"error":""},"__N_SSP":true},"page":"/cours/[sheetSlug]/[resourceType]","query":{"sheetSlug":"arbres-et-structure-de-donnees","resourceType":"fiche-de-revision"},"buildId":"7PMSe9KUa3QZbNQBS6zJb","assetPrefix":"/content","runtimeConfig":{"SCHOOLMOUV_BASE_URL":"https://www.schoolmouv.fr","SCHOOLMOUV_DOMAIN":"schoolmouv.fr","SCHOOLMOUV_OFFER_URL":"https://offres.schoolmouv.fr","SCHOOLMOUV_GTM_TAG":"GTM-55RGLG","SCHOOLMOUV_GRAPHQL_URL":"https://www.schoolmouv.fr/content/graphql","SCHOOLMOUV_GTM_ENABLE":"true","POOOL_APP_ID":"HV0P5-2T16H-JF0FQ-01JPD","POOOL_ENABLED":"true"},"isFallback":false,"gssp":true,"scriptLoader":[]}</script>
</body>
</html>
